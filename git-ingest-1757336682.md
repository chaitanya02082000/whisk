## 🏗️ Directory Structure

```
├── src
│   ├── components
│   │   ├── Auth.css
│   │   ├── Auth.jsx
│   │   ├── card.css
│   │   ├── card.jsx
│   │   ├── chips.css
│   │   ├── chips.jsx
│   │   ├── ClearChatButton.css
│   │   ├── ClearChatButton.jsx
│   │   ├── hero.css
│   │   ├── hero.jsx
│   │   ├── importRecipe.jsx
│   │   ├── RecipeChat.css
│   │   ├── RecipeChat.jsx
│   │   ├── RecipeDetail.css
│   │   ├── RecipeDetail.jsx
│   │   ├── sidebar.css
│   │   └── sidebar.jsx
│   ├── contexts
│   │   ├── Auth.css
│   │   ├── Auth.jsx
│   │   ├── ChatContext.jsx
│   │   ├── RecipeContext.jsx
│   │   └── SidebarContext.jsx
│   ├── App.css
│   ├── App.jsx
│   ├── index.css
│   └── main.jsx
├── eslint.config.js
├── index.html
├── package.json
├── README.md
└── vite.config.js
```

```javascript
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
  globalIgnores(["dist"]),
  {
    files: ["**/*.{js,jsx}"],
    extends: [
      js.configs.recommended,
      reactHooks.configs["recommended-latest"],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: "latest",
        ecmaFeatures: { jsx: true },
        sourceType: "module",
      },
    },
    rules: {
      "no-unused-vars": ["error", { varsIgnorePattern: "^[A-Z_]" }],
    },
  },
]);
```

### 📄 `index.html`

**Path:** `index.html`  
**Size:** 871 B  
**Language:** html (medium confidence)  
**Category:** Web Frontend

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&display=swap"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&display=swap"
        rel="stylesheet"
      />
    </noscript>

    <title>Whisk</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

### 📄 `package.json`

**Path:** `package.json`  
**Size:** 697 B  
**Language:** json (high confidence)  
**Category:** Data/Config

```json
{
  "name": "whisk",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@clerk/clerk-react": "^5.46.1",
    "axios": "^1.11.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.8.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "vite": "^7.1.2"
  }
}
```

### 📄 `App.jsx`

**Path:** `src/App.jsx`  
**Size:** 2.1 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import { Routes, Route } from "react-router-dom";
import {
  SignedIn,
  SignedOut,
  SignInButton,
  UserButton,
} from "@clerk/clerk-react";
import { RecipeProvider } from "./contexts/RecipeContext";
import { SidebarProvider } from "./contexts/SidebarContext";
import Sidebar from "./components/sidebar";
import Hero from "./components/hero";
import RecipeDetail from "./components/RecipeDetail";
import { useSidebar } from "./contexts/SidebarContext";
import "./App.css";

// Welcome screen for unauthenticated users
const WelcomeScreen = () => {
  return (
    <div className="welcome-screen">
      <div className="welcome-content">
        <h1>Welcome to Whisk</h1>
        <p>Your personal recipe collection and AI cooking assistant</p>
        <SignInButton mode="modal">
          <button className="sign-in-btn">Sign In to Get Started</button>
        </SignInButton>
      </div>
    </div>
  );
};

// Create a Layout component within App.jsx
const Layout = () => {
  const { isCollapsed, toggleSidebar } = useSidebar();

  return (
    <div className="main">
      {/* User Button - Top Right */}
      <div className="user-section">
        <UserButton
          appearance={{
            elements: {
              avatarBox: "w-8 h-8",
            },
          }}
        />
      </div>

      {/* Sidebar Toggle Button */}
      <button
        className={`sidebar-toggle ${!isCollapsed ? "hidden" : ""}`}
        onClick={toggleSidebar}
        title="Show sidebar"
      >
        ☰
      </button>

      {/* Sidebar */}
      <Sidebar className={isCollapsed ? "collapsed" : ""} />

      {/* Main Content */}
      <main className={`content ${isCollapsed ? "sidebar-collapsed" : ""}`}>
        <Routes>
          <Route path="/" element={<Hero />} />
          <Route path="/recipe/:id" element={<RecipeDetail />} />
        </Routes>
      </main>
    </div>
  );
};

function App() {
  return (
    <>
      <SignedIn>
        <RecipeProvider>
          <SidebarProvider>
            <Layout />
          </SidebarProvider>
        </RecipeProvider>
      </SignedIn>
      <SignedOut>
        <WelcomeScreen />
      </SignedOut>
    </>
  );
}

export default App;
```

### 📄 `Auth.css`

**Path:** `src/components/Auth.css`  
**Size:** 1.8 KB  
**Language:** css (medium confidence)  
**Category:** Web Frontend

````

### 📄 `Auth.jsx`

**Path:** `src/components/Auth.jsx`
**Size:** 7 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useState, createContext, useContext, useEffect } from "react";
import "./Auth.css";

// Auth Context
const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(localStorage.getItem("token"));

  useEffect(() => {
    if (token) {
      // Verify token with backend
      fetch("/api/auth/verify", {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
        .then((res) => res.json())
        .then((data) => {
          if (data.user) {
            setUser(data.user);
          } else {
            localStorage.removeItem("token");
            setToken(null);
          }
        })
        .catch(() => {
          localStorage.removeItem("token");
          setToken(null);
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, [token]);

  const login = async (email, password) => {
    const response = await fetch("/api/auth/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    const data = await response.json();

    if (response.ok) {
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem("token", data.token);
      return { success: true };
    } else {
      return { success: false, error: data.error };
    }
  };

  const register = async (username, email, password) => {
    const response = await fetch("/api/auth/register", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ username, email, password }),
    });

    const data = await response.json();

    if (response.ok) {
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem("token", data.token);
      return { success: true };
    } else {
      return { success: false, error: data.error };
    }
  };

  const logout = () => {
    setToken(null);
    setUser(null);
    localStorage.removeItem("token");
  };

  const value = {
    user,
    token,
    login,
    register,
    logout,
    loading,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Login Component
export const LoginForm = ({ onToggle }) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const { login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    const result = await login(email, password);

    if (!result.success) {
      setError(result.error);
    }

    setLoading(false);
  };

  return (
    <form onSubmit={handleSubmit} className="auth-form">
      <h2>Login</h2>
      {error && <div className="error-message">{error}</div>}

      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>

      <button type="submit" disabled={loading} className="auth-button">
        {loading ? "Logging in..." : "Login"}
      </button>

      <p className="auth-toggle">
        Don't have an account?{" "}
        <button type="button" onClick={onToggle} className="link-button">
          Register here
        </button>
      </p>
    </form>
  );
};

// Register Component
export const RegisterForm = ({ onToggle }) => {
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const { register } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    if (password.length < 6) {
      setError("Password must be at least 6 characters long");
      return;
    }

    setLoading(true);

    const result = await register(username, email, password);

    if (!result.success) {
      setError(result.error);
    }

    setLoading(false);
  };

  return (
    <form onSubmit={handleSubmit} className="auth-form">
      <h2>Register</h2>
      {error && <div className="error-message">{error}</div>}

      <div className="form-group">
        <label htmlFor="username">Username:</label>
        <input
          type="text"
          id="username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="confirmPassword">Confirm Password:</label>
        <input
          type="password"
          id="confirmPassword"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
        />
      </div>

      <button type="submit" disabled={loading} className="auth-button">
        {loading ? "Creating account..." : "Register"}
      </button>

      <p className="auth-toggle">
        Already have an account?{" "}
        <button type="button" onClick={onToggle} className="link-button">
          Login here
        </button>
      </p>
    </form>
  );
};

// Auth Modal Component
export const AuthModal = ({ isOpen, onClose }) => {
  const [isLogin, setIsLogin] = useState(true);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <button className="modal-close" onClick={onClose}>
          ×
        </button>
        {isLogin ? (
          <LoginForm onToggle={() => setIsLogin(false)} />
        ) : (
          <RegisterForm onToggle={() => setIsLogin(true)} />
        )}
      </div>
    </div>
  );
};
```

### 📄 `ClearChatButton.css`

**Path:** `src/components/ClearChatButton.css`
**Size:** 1.1 KB
**Language:** css (medium confidence)
**Category:** Web Frontend
```css
```

### 📄 `ClearChatButton.jsx`

**Path:** `src/components/ClearChatButton.jsx`
**Size:** 1.7 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import React, { useState } from "react";
import { useChat } from "../contexts/ChatContext";

import "./ClearChatButton.css";
const ClearChatButton = ({ recipeId, variant = "chat" }) => {
  const { clearChatHistory, clearAllNotes, loading } = useChat();
  const [showConfirm, setShowConfirm] = useState(false);

  const handleClear = async () => {
    try {
      if (variant === "chat") {
        await clearChatHistory(recipeId);
      } else {
        await clearAllNotes(recipeId);
      }
      setShowConfirm(false);
    } catch (error) {
      console.error("Failed to clear:", error);
    }
  };

  const buttonText =
    variant === "chat" ? "Clear Chat History" : "Clear All Notes";
  const confirmText =
    variant === "chat"
      ? "Are you sure you want to clear the chat history? This cannot be undone."
      : "Are you sure you want to clear all notes and chat history? This cannot be undone.";

  if (showConfirm) {
    return (
      <div className="clear-chat-confirm">
        <p className="confirm-text">{confirmText}</p>
        <div className="confirm-buttons">
          <button
            onClick={handleClear}
            disabled={loading}
            className="btn btn-danger"
          >
            {loading ? "Clearing..." : "Yes, Clear"}
          </button>
          <button
            onClick={() => setShowConfirm(false)}
            className="btn btn-secondary"
          >
            Cancel
          </button>
        </div>
      </div>
    );
  }

  return (
    <button
      onClick={() => setShowConfirm(true)}
      className="btn btn-outline-danger clear-chat-btn"
      title={buttonText}
    >
      <span className="icon">🗑️</span>
      {buttonText}
    </button>
  );
};

export default ClearChatButton;
```

### 📄 `RecipeChat.css`

**Path:** `src/components/RecipeChat.css`
**Size:** 10.6 KB
**Language:** css (medium confidence)
**Category:** Web Frontend
**Path:** `src/components/RecipeChat.jsx`
**Size:** 8.5 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useState, useEffect, useRef } from "react";
import { useChat } from "../contexts/ChatContext";
import "./RecipeChat.css";

const RecipeChat = ({ recipe, activeView, onViewChange }) => {
  const [message, setMessage] = useState("");
  const [noteContent, setNoteContent] = useState("");
  const [showClearConfirm, setShowClearConfirm] = useState(false);

  const {
    notes,
    loading,
    sendChatMessage,
    saveNote,
    deleteNote,
    fetchNotes,
    clearChatHistory, // Add this
    error,
  } = useChat();

  const messagesEndRef = useRef(null);

  useEffect(() => {
    if (recipe?._id) {
      fetchNotes(recipe._id);
    }
  }, [recipe?._id]);

  useEffect(() => {
    scrollToBottom();
  }, [notes]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!message.trim()) return;

    try {
      await sendChatMessage(recipe._id, message);
      setMessage("");
    } catch (error) {
      console.error("Failed to send message:", error);
    }
  };

  const handleSaveNote = async (e) => {
    e.preventDefault();
    if (!noteContent.trim()) return;

    try {
      await saveNote(recipe._id, noteContent);
      setNoteContent("");
    } catch (error) {
      console.error("Failed to save note:", error);
    }
  };

  const handleSaveChatAsNote = async (chatMessage) => {
    try {
      const noteText = chatMessage.isFromAI
        ? `💡 AI Tip: ${chatMessage.content}`
        : `💭 My Question: ${chatMessage.content}`;

      await saveNote(recipe._id, noteText);
      alert("Message saved to notes!");
    } catch (error) {
      console.error("Failed to save chat as note:", error);
      alert("Failed to save message to notes");
    }
  };

  // New function to handle clearing chat history
  const handleClearChat = async () => {
    try {
      await clearChatHistory(recipe._id);
      setShowClearConfirm(false);
    } catch (error) {
      console.error("Failed to clear chat:", error);
      alert("Failed to clear chat history");
    }
  };

  const chatMessages = notes.filter((note) => note.type === "chat");
  const savedNotes = notes.filter((note) => note.type === "note");

  return (
    <div className="recipe-chat">
      <div className="chat-header">
        <h3>Recipe Assistant</h3>
        <div className="view-toggle">
          <button
            className={activeView === "chat" ? "active" : ""}
            onClick={() => onViewChange("chat")}
          >
            💬 Chat ({chatMessages.length})
          </button>
          <button
            className={activeView === "notes" ? "active" : ""}
            onClick={() => onViewChange("notes")}
          >
            📝 Notes ({savedNotes.length})
          </button>
        </div>
      </div>

      {/* Error display */}
      {error && <div className="error-message">{error}</div>}

      {activeView === "chat" && (
        <div className="chat-view">
          {/* Chat Actions */}
          {chatMessages.length > 0 && (
            <div className="chat-actions">
              {!showClearConfirm ? (
                <button
                  className="clear-chat-btn"
                  onClick={() => setShowClearConfirm(true)}
                  title="Clear chat history"
                >
                  🗑️ Clear Chat
                </button>
              ) : (
                <div className="clear-confirm">
                  <span>Clear all chat messages?</span>
                  <button
                    className="confirm-yes"
                    onClick={handleClearChat}
                    disabled={loading}
                  >
                    {loading ? "⏳" : "✓"} Yes
                  </button>
                  <button
                    className="confirm-no"
                    onClick={() => setShowClearConfirm(false)}
                  >
                    ✗ Cancel
                  </button>
                </div>
              )}
            </div>
          )}

          <div className="messages-container">
            {chatMessages.length === 0 ? (
              <div className="empty-state">
                <p>Ask me anything about this recipe!</p>
                <div className="suggestion-chips">
                  <button
                    onClick={() =>
                      setMessage("Can I substitute any ingredients?")
                    }
                  >
                    Substitutions?
                  </button>
                  <button
                    onClick={() =>
                      setMessage("Any cooking tips for this recipe?")
                    }
                  >
                    Cooking tips?
                  </button>
                  <button
                    onClick={() => setMessage("How can I make this healthier?")}
                  >
                    Make it healthier?
                  </button>
                </div>
              </div>
            ) : (
              chatMessages.map((note) => (
                <div
                  key={note._id}
                  className={`message ${note.isFromAI ? "ai-message" : "user-message"}`}
                >
                  <div className="message-content">
                    {/* Better formatting for AI responses */}
                    {note.isFromAI ? (
                      <div className="ai-response">
                        {note.content.split("\n\n").map((paragraph, index) => (
                          <p key={index}>{paragraph}</p>
                        ))}
                      </div>
                    ) : (
                      note.content
                    )}
                  </div>
                  <div className="message-footer">
                    <div className="message-time">
                      {new Date(note.timestamp).toLocaleTimeString()}
                    </div>
                    <button
                      className="save-to-notes-btn"
                      onClick={() => handleSaveChatAsNote(note)}
                      title="Save this message to notes"
                    >
                      📝
                    </button>
                  </div>
                </div>
              ))
            )}
            <div ref={messagesEndRef} />
          </div>

          <form onSubmit={handleSendMessage} className="message-form">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Ask about ingredients, cooking tips, substitutions..."
              disabled={loading}
            />
            <button type="submit" disabled={loading || !message.trim()}>
              {loading ? "⏳" : "➤"}
            </button>
          </form>
        </div>
      )}

      {activeView === "notes" && (
        <div className="notes-view">
          <form onSubmit={handleSaveNote} className="note-form">
            <textarea
              value={noteContent}
              onChange={(e) => setNoteContent(e.target.value)}
              placeholder="Add your personal notes about this recipe..."
              rows="3"
            />
            <button type="submit" disabled={!noteContent.trim()}>
              💾 Save Note
            </button>
          </form>

          <div className="notes-list">
            {savedNotes.length === 0 ? (
              <div className="empty-state">
                <p>No notes yet!</p>
                <p>
                  💡 <strong>Tip:</strong> You can save chat messages as notes
                  by clicking the 📝 button next to any message in the chat.
                </p>
              </div>
            ) : (
              savedNotes.map((note) => (
                <div key={note._id} className="note-item">
                  <div className="note-content">{note.content}</div>
                  <div className="note-footer">
                    <span className="note-time">
                      {new Date(note.timestamp).toLocaleDateString()} at{" "}
                      {new Date(note.timestamp).toLocaleTimeString()}
                    </span>
                    <button
                      onClick={() => deleteNote(note._id)}
                      className="delete-note-btn"
                      title="Delete this note"
                    >
                      🗑️
                    </button>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default RecipeChat;
```

### 📄 `RecipeDetail.jsx`

**Path:** `src/components/RecipeDetail.jsx`
**Size:** 4.7 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useParams, useNavigate, Link } from "react-router-dom";
import { useState } from "react";
import { useRecipes } from "../contexts/RecipeContext";
import { ChatProvider } from "../contexts/ChatContext";
import RecipeChat from "./RecipeChat";
import "./RecipeDetail.css";

const RecipeDetail = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const { recipes, loading, deleteRecipe } = useRecipes();
  const [chatView, setChatView] = useState("chat");

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <h2>Loading recipe...</h2>
      </div>
    );
  }

  const recipe = recipes.find((r) => r._id === id);

  if (!recipe) {
    return (
      <div className="error-container">
        <h2>Recipe not found</h2>
        <p>The recipe you're looking for doesn't exist or has been removed.</p>
        <Link to="/" className="back-button">
          ← Back to Home
        </Link>
      </div>
    );
  }

  const handleDelete = async () => {
    if (window.confirm("Are you sure you want to delete this recipe?")) {
      try {
        await deleteRecipe(recipe._id);
        navigate("/");
      } catch (error) {
        console.error("Error deleting recipe:", error);
        alert("Failed to delete recipe");
      }
    }
  };

  return (
    <ChatProvider>
      <div className="recipe-detail-layout">
        {/* Main Recipe Content */}
        <div className="recipe-main-content">
          <div className="recipe-header">
            <Link to="/" className="back-button">
              ← Back to Recipes
            </Link>
            <div className="recipe-actions">
              <button onClick={handleDelete} className="delete-btn">
                🗑️ Delete Recipe
              </button>
            </div>
          </div>

          <div className="recipe-title-section">
            <h1>{recipe.name}</h1>
            {recipe.description && (
              <p className="recipe-description">{recipe.description}</p>
            )}
          </div>

          {recipe.image && (
            <div className="recipe-image-container">
              <img
                src={recipe.image}
                alt={recipe.name}
                className="recipe-detail-image"
              />
            </div>
          )}

          <div className="recipe-meta">
            <div className="time-info">
              {recipe.prepTime && (
                <span className="meta-item">Prep: {recipe.prepTime}</span>
              )}
              {recipe.cookTime && (
                <span className="meta-item">Cook: {recipe.cookTime}</span>
              )}
              {recipe.totalTime && (
                <span className="meta-item">Total: {recipe.totalTime}</span>
              )}
              {recipe.yield && (
                <span className="meta-item">Serves: {recipe.yield}</span>
              )}
            </div>

            <div className="recipe-tags">
              {recipe.category?.map((cat, index) => (
                <span key={index} className="tag category-tag">
                  {cat}
                </span>
              ))}
              {recipe.cuisine?.map((cuisine, index) => (
                <span key={index} className="tag cuisine-tag">
                  {cuisine}
                </span>
              ))}
            </div>
          </div>

          <div className="recipe-content">
            <div className="ingredients-section">
              <h2>Ingredients</h2>
              <ul className="ingredients-list">
                {recipe.ingredients?.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>

            <div className="instructions-section">
              <h2>Instructions</h2>
              <ol className="instructions-list">
                {recipe.instructions?.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {recipe.sourceUrl && recipe.sourceUrl !== "manual-input" && (
            <div className="recipe-source">
              <a
                href={recipe.sourceUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="source-link"
              >
                🔗 View Original Recipe
              </a>
            </div>
          )}
        </div>

        {/* Chat Sidebar */}
        <div className="recipe-chat-sidebar">
          <RecipeChat
            recipe={recipe}
            activeView={chatView}
            onViewChange={setChatView}
          />
        </div>
      </div>
    </ChatProvider>
  );
};

export default RecipeDetail;
```

```

### 📄 `card.jsx`

**Path:** `src/components/card.jsx`
**Size:** 1.4 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useNavigate } from "react-router-dom";

const Card = ({ heading, summary, recipe }) => {
  const navigate = useNavigate();

  const handleClick = () => {
    // Navigate to recipe detail page
    navigate(`/recipe/${recipe._id}`);
  };

  return (
    <div className="recipe-card" onClick={handleClick}>
      <h2>{heading}</h2>

      {summary && <p>{summary}</p>}

      {/* Time information */}
      {(recipe.prepTime || recipe.cookTime || recipe.totalTime) && (
        <div className="time">
          {recipe.prepTime && (
            <div>
              <span>Prep: {recipe.prepTime}</span>
            </div>
          )}
          {recipe.cookTime && (
            <div>
              <span>Cook: {recipe.cookTime}</span>
            </div>
          )}
          {recipe.totalTime && (
            <div>
              <span>Total: {recipe.totalTime}</span>
            </div>
          )}
        </div>
      )}

      {/* Categories */}
      {(recipe.category?.length > 0 || recipe.cuisine?.length > 0) && (
        <div className="categories">
          {recipe.category?.slice(0, 3).map((cat, index) => (
            <span key={index} className="category-tag">
              {cat}
            </span>
          ))}
          {recipe.cuisine?.slice(0, 2).map((cuisine, index) => (
            <span key={index} className="category-tag">
              {cuisine}
            </span>
          ))}
        </div>
      )}
    </div>
  );
};

export default Card;
```


### 📄 `chips.jsx`

**Path:** `src/components/chips.jsx`
**Size:** 2.9 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useState, useEffect } from "react";
import { useRecipes } from "../contexts/RecipeContext";
import "./chips.css";

const Chips = ({ onChipsChange }) => {
  const [text, setText] = useState("");
  const [chips, setChips] = useState([]);
  const [availableTags, setAvailableTags] = useState([]);

  const { recipes } = useRecipes();

  useEffect(() => {
    if (recipes.length > 0) {
      const categories = recipes.flatMap((recipe) => recipe.category || []);
      const cuisines = recipes.flatMap((recipe) => recipe.cuisine || []);
      const allTags = [...new Set([...categories, ...cuisines])];
      setAvailableTags(allTags);
    }
  }, [recipes]);

  useEffect(() => {
    if (onChipsChange) {
      onChipsChange(chips);
    }
  }, [chips, onChipsChange]);

  const handleKey = (e) => {
    if (e.key === "Enter" && text.trim()) {
      e.preventDefault();
      if (!chips.includes(text.trim())) {
        setChips((prev) => [...prev, text.trim()]);
      }
      setText("");
    }
  };

  const removeChip = (indexToRemove) => {
    setChips(chips.filter((_, index) => index !== indexToRemove));
  };

  const addTagChip = (tag) => {
    if (!chips.includes(tag)) {
      setChips((prev) => [...prev, tag]);
    }
  };

  const clearAllChips = () => {
    setChips([]);
  };

  return (
    <div className="chips-container">
      <input
        className="chips-input"
        value={text}
        onChange={(e) => setText(e.target.value)}
        onKeyDown={handleKey}
        placeholder="Add custom tags... (Press Enter)"
      />

      {availableTags.length > 0 && (
        <div className="chips-section">
          <div className="chips-section-header">
            <h4 className="chips-section-title">
              Available from your recipes:
            </h4>
            {chips.length > 0 && (
              <button className="chips-clear-button" onClick={clearAllChips}>
                Clear all
              </button>
            )}
          </div>
          <div className="chips-available">
            {availableTags.map((tag, index) => (
              <button
                key={index}
                className="chip-available"
                onClick={() => addTagChip(tag)}
                disabled={chips.includes(tag)}
              >
                {tag}
              </button>
            ))}
          </div>
        </div>
      )}

      {chips.length > 0 && (
        <div className="chips-section">
          <h4 className="chips-section-title">Active filters:</h4>
          <div className="chips-selected">
            {chips.map((chip, index) => (
              <div key={index} className="chip-selected">
                {chip}
                <button
                  className="chip-remove-button"
                  onClick={() => removeChip(index)}
                >
                  ×
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default Chips;
```

```

### 📄 `hero.jsx`

**Path:** `src/components/hero.jsx`
**Size:** 5.8 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useEffect, useState } from "react";
import "./hero.css";
import Chips from "./chips";
import Card from "./card";
// Remove the RecipeModal import
import { useRecipes } from "../contexts/RecipeContext";

const Hero = () => {
  const [search, setSearch] = useState("");
  const [filteredRecipes, setFilteredRecipes] = useState([]);
  const [selectedChips, setSelectedChips] = useState([]);
  const [category, setCategory] = useState("");
  const [cuisine, setCuisine] = useState("");

  // Remove modal state - we don't need it anymore
  // const [selectedRecipe, setSelectedRecipe] = useState(null);
  // const [isModalOpen, setIsModalOpen] = useState(false);

  // Get data and functions from context
  const { recipes, loading, error } = useRecipes();

  const inputWidth = `${Math.max(30, search.length + 2)}ch`;

  // Update filtered recipes when recipes change
  useEffect(() => {
    setFilteredRecipes(recipes);
  }, [recipes]);

  // Filter recipes based on search, category, and cuisine
  useEffect(() => {
    let filtered = recipes;

    if (search) {
      filtered = filtered.filter(
        (recipe) =>
          recipe.name.toLowerCase().includes(search.toLowerCase()) ||
          recipe.description?.toLowerCase().includes(search.toLowerCase()),
      );
    }

    if (category) {
      filtered = filtered.filter((recipe) =>
        recipe.category?.includes(category),
      );
    }

    if (cuisine) {
      filtered = filtered.filter((recipe) => recipe.cuisine?.includes(cuisine));
    }

    // Filter by selected chips
    if (selectedChips.length > 0) {
      filtered = filtered.filter((recipe) => {
        const recipeTags = [
          ...(recipe.category || []),
          ...(recipe.cuisine || []),
        ];
        return selectedChips.some((chip) => recipeTags.includes(chip));
      });
    }

    setFilteredRecipes(filtered);
  }, [search, category, cuisine, selectedChips, recipes]);

  // Remove modal handlers - we don't need them anymore
  // const handleRecipeClick = (recipe) => {
  //   setSelectedRecipe(recipe);
  //   setIsModalOpen(true);
  // };

  // const handleCloseModal = () => {
  //   setIsModalOpen(false);
  //   setSelectedRecipe(null);
  // };

  // Remove keyboard navigation for modal
  // useEffect(() => {
  //   const handleEscape = (event) => {
  //     if (event.key === "Escape") {
  //       handleCloseModal();
  //     }
  //   };

  //   if (isModalOpen) {
  //     document.addEventListener("keydown", handleEscape);
  //     document.body.style.overflow = "hidden";
  //   }

  //   return () => {
  //     document.removeEventListener("keydown", handleEscape);
  //     document.body.style.overflow = "unset";
  //   };
  // }, [isModalOpen]);

  const handleCategoryChange = (e) => {
    setCategory(e.target.value);
  };

  const handleCuisineChange = (e) => {
    setCuisine(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
  };

  // Extract unique categories and cuisines for dropdowns
  const categories = [
    ...new Set(recipes.flatMap((recipe) => recipe.category || [])),
  ];
  const cuisines = [
    ...new Set(recipes.flatMap((recipe) => recipe.cuisine || [])),
  ];

  // Handle loading state
  if (loading) {
    return (
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Loading recipes...</h2>
        </div>
      </div>
    );
  }

  // Handle error state
  if (error) {
    return (
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Error: {error}</h2>
        </div>
      </div>
    );
  }

  return (
    <>
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Discover, Organize, and cook your favourite recipes.</h2>
        </div>
        <div className="search">
          <form onSubmit={handleSubmit}>
            <input
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder="Search recipes or ask questions(eg., 'Show me a quick dinner recipe.')"
              style={{ width: inputWidth, height: "3em" }}
            />
          </form>
          <div className="dropdown">
            <select
              className="dropdown-1"
              value={category}
              onChange={handleCategoryChange}
            >
              <option value="">All Categories</option>
              {categories.map((cat) => (
                <option key={cat} value={cat}>
                  {cat}
                </option>
              ))}
            </select>
            <select
              className="dropdown-2"
              value={cuisine}
              onChange={handleCuisineChange}
            >
              <option value="">All Cuisines</option>
              {cuisines.map((cui) => (
                <option key={cui} value={cui}>
                  {cui}
                </option>
              ))}
            </select>
          </div>
          <Chips onChipsChange={setSelectedChips} />
        </div>
      </div>

      {/* Recipes display section */}
      <div className="recipes-grid">
        {filteredRecipes.length > 0 ? (
          filteredRecipes.map((recipe) => (
            <Card
              key={recipe._id}
              heading={recipe.name}
              summary={recipe.description}
              recipe={recipe}
              // Remove onClick prop - Card will handle navigation internally
            />
          ))
        ) : (
          <div className="no-recipes">
            <h3>No recipes found</h3>
            <p>Try adjusting your search terms or filters to find recipes.</p>
          </div>
        )}
      </div>

      {/* Remove the modal */}
      {/* <RecipeModal
        recipe={selectedRecipe}
        isOpen={isModalOpen}
        onClose={handleCloseModal}
      /> */}
    </>
  );
};

export default Hero;
```

### 📄 `importRecipe.jsx`

**Path:** `src/components/importRecipe.jsx`
**Size:** 1.8 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useState } from "react";
import { useRecipes } from "../contexts/RecipeContext";

import "./sidebar.css";

const Button = ({ children, onSuccess, onError }) => {
  const [recipeUrl, setRecipeUrl] = useState("");
  const [loading, setLoading] = useState(false);

  // Use the parseAndAddRecipe function from context
  const { parseAndAddRecipe } = useRecipes();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!recipeUrl.trim()) {
      alert("Please enter a recipe URL");
      return;
    }

    // Validate URL format
    try {
      new URL(recipeUrl);
    } catch {
      alert("Please enter a valid URL");
      return;
    }

    setLoading(true);
    console.log("Submitting URL:", recipeUrl);

    try {
      const recipe = await parseAndAddRecipe(recipeUrl);
      console.log("Recipe parsed and added:", recipe);
      setRecipeUrl("");

      if (onSuccess) {
        onSuccess(recipe);
      }
    } catch (error) {
      console.error("Error parsing recipe:", error);

      // Show user-friendly error message
      const errorMessage =
        error.response?.data?.message ||
        error.response?.data?.error ||
        "Failed to parse recipe. Please try again.";
      alert(errorMessage);

      if (onError) {
        onError(error);
      }
    } finally {
      // Always reset loading state
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={recipeUrl}
        onChange={(e) => setRecipeUrl(e.target.value)}
        placeholder="Paste recipe URL here"
        className="recipe-input"
        disabled={loading}
      />
      <button className="sidebar-button" type="submit" disabled={loading}>
        {loading ? "Processing..." : children || "Parse Recipe"}
      </button>
    </form>
  );
};

export default Button;
```


**Path:** `src/components/sidebar.jsx`
**Size:** 1.5 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { Link, useNavigate } from "react-router-dom";
import Button from "./importRecipe.jsx";
import { useSidebar } from "../contexts/SidebarContext";
import "./sidebar.css";

const Sidebar = ({ className = "" }) => {
  const navigate = useNavigate();
  const { isCollapsed, toggleSidebar } = useSidebar();

  const handleRecipeAdded = (recipe) => {
    console.log("Recipe added successfully:", recipe);
    // Navigate to the newly added recipe
    navigate(`/recipe/${recipe._id}`);
  };

  const handleRecipeError = (error) => {
    console.error("Error adding recipe:", error);
  };

  return (
    <aside className={`sidebar ${className}`}>
      <div className="sidebar-content">
        {/* Close button for when sidebar is open */}
        {!isCollapsed && (
          <button
            className="sidebar-close"
            onClick={toggleSidebar}
            title="Hide sidebar"
          >
            ✕
          </button>
        )}

        {/* Logo/Title that links to home */}
        <Link to="/" className="sidebar-title">
          <h3>Whisk</h3>
        </Link>

        {/* Add Recipe Section */}
        <div className="add-recipe-section">
          <h4>Add Recipe</h4>
          <Button onSuccess={handleRecipeAdded} onError={handleRecipeError}>
            Import Recipe
          </Button>
        </div>

        {/* Simple stats or info */}
        <div className="sidebar-info">
          <p>Discover and organize your favorite recipes</p>
        </div>
      </div>
    </aside>
  );
};

export default Sidebar;
```

### 📄 `Auth.jsx`

**Path:** `src/contexts/Auth.jsx`
**Size:** 7 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { useState, createContext, useContext, useEffect } from "react";
import "./Auth.css";

// Auth Context
const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(localStorage.getItem("token"));

  useEffect(() => {
    if (token) {
      // Verify token with backend
      fetch("/api/auth/verify", {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
        .then((res) => res.json())
        .then((data) => {
          if (data.user) {
            setUser(data.user);
          } else {
            localStorage.removeItem("token");
            setToken(null);
          }
        })
        .catch(() => {
          localStorage.removeItem("token");
          setToken(null);
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, [token]);

  const login = async (email, password) => {
    const response = await fetch("/api/auth/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    const data = await response.json();

    if (response.ok) {
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem("token", data.token);
      return { success: true };
    } else {
      return { success: false, error: data.error };
    }
  };

  const register = async (username, email, password) => {
    const response = await fetch("/api/auth/register", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ username, email, password }),
    });

    const data = await response.json();

    if (response.ok) {
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem("token", data.token);
      return { success: true };
    } else {
      return { success: false, error: data.error };
    }
  };

  const logout = () => {
    setToken(null);
    setUser(null);
    localStorage.removeItem("token");
  };

  const value = {
    user,
    token,
    login,
    register,
    logout,
    loading,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Login Component
export const LoginForm = ({ onToggle }) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const { login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    const result = await login(email, password);

    if (!result.success) {
      setError(result.error);
    }

    setLoading(false);
  };

  return (
    <form onSubmit={handleSubmit} className="auth-form">
      <h2>Login</h2>
      {error && <div className="error-message">{error}</div>}

      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>

      <button type="submit" disabled={loading} className="auth-button">
        {loading ? "Logging in..." : "Login"}
      </button>

      <p className="auth-toggle">
        Don't have an account?{" "}
        <button type="button" onClick={onToggle} className="link-button">
          Register here
        </button>
      </p>
    </form>
  );
};

// Register Component
export const RegisterForm = ({ onToggle }) => {
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const { register } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    if (password.length < 6) {
      setError("Password must be at least 6 characters long");
      return;
    }

    setLoading(true);

    const result = await register(username, email, password);

    if (!result.success) {
      setError(result.error);
    }

    setLoading(false);
  };

  return (
    <form onSubmit={handleSubmit} className="auth-form">
      <h2>Register</h2>
      {error && <div className="error-message">{error}</div>}

      <div className="form-group">
        <label htmlFor="username">Username:</label>
        <input
          type="text"
          id="username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="confirmPassword">Confirm Password:</label>
        <input
          type="password"
          id="confirmPassword"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
        />
      </div>

      <button type="submit" disabled={loading} className="auth-button">
        {loading ? "Creating account..." : "Register"}
      </button>

      <p className="auth-toggle">
        Already have an account?{" "}
        <button type="button" onClick={onToggle} className="link-button">
          Login here
        </button>
      </p>
    </form>
  );
};

// Auth Modal Component
export const AuthModal = ({ isOpen, onClose }) => {
  const [isLogin, setIsLogin] = useState(true);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <button className="modal-close" onClick={onClose}>
          ×
        </button>
        {isLogin ? (
          <LoginForm onToggle={() => setIsLogin(false)} />
        ) : (
          <RegisterForm onToggle={() => setIsLogin(true)} />
        )}
      </div>
    </div>
  );
};
```

### 📄 `ChatContext.jsx`

**Path:** `src/contexts/ChatContext.jsx`
**Size:** 6.5 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import React, { createContext, useContext, useState, useCallback } from "react";
import axios from "axios";

const CHAT_URL = import.meta.env.VITE_CHAT_URL;
const ChatContext = createContext();

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error("useChat must be used within a ChatProvider");
  }
  return context;
};

export const ChatProvider = ({ children }) => {
  const [notes, setNotes] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [chatHistory, setChatHistory] = useState({}); // Store chat history per recipe
  // Add this new function
  const clearChatHistory = async (recipeId) => {
    try {
      setError(null);
      setLoading(true);

      const apiUrl = `${CHAT_URL}/recipes/${recipeId}/chat`;
      const response = await axios.delete(apiUrl);

      // Remove chat messages from local state (keep notes)
      setNotes((prev) =>
        prev.filter(
          (note) => !(note.recipeId === recipeId && note.type === "chat"),
        ),
      );

      console.log(
        `✅ Cleared chat history: ${response.data.deletedCount} messages`,
      );
      return response.data;
    } catch (error) {
      console.error("Error clearing chat history:", error);
      const errorMessage =
        error.response?.data?.error || "Failed to clear chat history";
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  // Clear all notes and chats for a recipe
  const clearAllNotes = async (recipeId) => {
    try {
      setError(null);
      setLoading(true);

      const apiUrl = `${CHAT_URL}/recipes/${recipeId}/all-notes`;
      const response = await axios.delete(apiUrl);

      // Remove all notes for this recipe from local state
      setNotes((prev) => prev.filter((note) => note.recipeId !== recipeId));

      console.log(`✅ Cleared all notes: ${response.data.deletedCount} items`);
      return response.data;
    } catch (error) {
      console.error("Error clearing all notes:", error);
      const errorMessage =
        error.response?.data?.error || "Failed to clear all notes";
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  // Enhanced error handling
  const handleError = useCallback((error, defaultMessage) => {
    console.error("API Error:", error);
    const errorMessage =
      error.response?.data?.error || error.message || defaultMessage;
    setError(errorMessage);
    return errorMessage;
  }, []);

  // Fetch notes for a recipe with caching
  const fetchNotes = useCallback(
    async (recipeId) => {
      try {
        setLoading(true);
        setError(null);

        const apiUrl = `${CHAT_URL}/recipes/${recipeId}/notes`;
        const response = await axios.get(apiUrl);

        setNotes(response.data);
        setChatHistory((prev) => ({
          ...prev,
          [recipeId]: response.data.filter((note) => note.type === "chat"),
        }));

        return response.data;
      } catch (error) {
        throw new Error(handleError(error, "Failed to fetch notes"));
      } finally {
        setLoading(false);
      }
    },
    [handleError],
  );

  // Enhanced chat message sending with optimistic updates
  const sendChatMessage = useCallback(
    async (recipeId, message) => {
      try {
        setLoading(true);
        setError(null);

        // Optimistic update - add user message immediately
        const tempUserMessage = {
          _id: `temp-${Date.now()}`,
          content: message,
          type: "chat",
          isFromAI: false,
          timestamp: new Date().toISOString(),
          recipeId,
        };

        setNotes((prev) => [...prev, tempUserMessage]);

        const apiUrl = `${CHAT_URL}/recipes/${recipeId}/chat`;
        const response = await axios.post(apiUrl, { message });

        // Remove temp message and add real messages
        setNotes((prev) => [
          ...prev.filter((note) => note._id !== tempUserMessage._id),
          response.data.userMessage,
          response.data.aiResponse,
        ]);

        // Update chat history
        setChatHistory((prev) => ({
          ...prev,
          [recipeId]: [
            ...(prev[recipeId] || []),
            response.data.userMessage,
            response.data.aiResponse,
          ],
        }));

        return response.data;
      } catch (error) {
        // Remove optimistic update on error
        setNotes((prev) =>
          prev.filter((note) => note._id !== `temp-${Date.now()}`),
        );
        throw new Error(handleError(error, "Failed to send message"));
      } finally {
        setLoading(false);
      }
    },
    [handleError],
  );

  // Enhanced note saving with validation
  const saveNote = useCallback(
    async (recipeId, content, type = "note") => {
      if (!content?.trim()) {
        throw new Error("Note content cannot be empty");
      }

      try {
        setError(null);
        const apiUrl = `${CHAT_URL}/recipes/${recipeId}/notes`;
        const response = await axios.post(apiUrl, {
          content: content.trim(),
          type,
        });

        setNotes((prev) => [...prev, response.data]);
        return response.data;
      } catch (error) {
        throw new Error(handleError(error, "Failed to save note"));
      }
    },
    [handleError],
  );

  // Fixed delete note function
  const deleteNote = useCallback(
    async (noteId) => {
      try {
        setError(null);
        const apiUrl = `${CHAT_URL}/notes/${noteId}`;

        await axios.delete(apiUrl);
        setNotes((prev) => prev.filter((note) => note._id !== noteId));

        // Update chat history
        setChatHistory((prev) => {
          const updated = { ...prev };
          Object.keys(updated).forEach((recipeId) => {
            updated[recipeId] = updated[recipeId].filter(
              (note) => note._id !== noteId,
            );
          });
          return updated;
        });
      } catch (error) {
        handleError(error, "Failed to delete note");
      }
    },
    [handleError],
  );

  // Get chat history for a specific recipe
  const getChatHistory = useCallback(
    (recipeId) => {
      return chatHistory[recipeId] || [];
    },
    [chatHistory],
  );

  const value = {
    notes,
    loading,
    error,
    chatHistory,
    fetchNotes,
    sendChatMessage,
    saveNote,
    deleteNote,
    getChatHistory,
    clearChatHistory,
    clearAllNotes,
    clearError: () => setError(null),
  };

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
};
```

### 📄 `RecipeContext.jsx`

**Path:** `src/contexts/RecipeContext.jsx`
**Size:** 2.8 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { createContext, useContext, useState, useEffect } from "react";
import { useAuth } from "@clerk/clerk-react";

const RecipeContext = createContext();

export function RecipeProvider({ children }) {
  const { getToken, isLoaded, userId } = useAuth();
  const [recipes, setRecipes] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // API helper with authentication
  const apiCall = async (url, options = {}) => {
    if (!isLoaded) {
      throw new Error("Auth not loaded yet");
    }

    const token = await getToken();

    return fetch(`http://localhost:3001${url}`, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
        ...options.headers,
      },
    });
  };

  const fetchRecipes = async () => {
    if (!isLoaded || !userId) return;

    try {
      setIsLoading(true);
      const response = await apiCall("/api/recipes");

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setRecipes(data);
    } catch (error) {
      console.error("Error fetching recipes:", error);
      setRecipes([]);
    } finally {
      setIsLoading(false);
    }
  };

  const addRecipe = async (recipeData) => {
    try {
      const response = await apiCall("/api/recipes/parse", {
        method: "POST",
        body: JSON.stringify(recipeData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to add recipe");
      }

      const newRecipe = await response.json();
      setRecipes((prev) => [newRecipe, ...prev]);
      return newRecipe;
    } catch (error) {
      console.error("Error adding recipe:", error);
      throw error;
    }
  };

  const deleteRecipe = async (recipeId) => {
    try {
      const response = await apiCall(`/api/recipes/${recipeId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete recipe");
      }

      setRecipes((prev) => prev.filter((recipe) => recipe._id !== recipeId));
    } catch (error) {
      console.error("Error deleting recipe:", error);
      throw error;
    }
  };

  // Fetch recipes when auth is loaded and user is available
  useEffect(() => {
    if (isLoaded && userId) {
      fetchRecipes();
    }
  }, [isLoaded, userId]);

  const value = {
    recipes,
    isLoading,
    fetchRecipes,
    addRecipe,
    deleteRecipe,
    apiCall, // Expose for other components
  };

  return (
    <RecipeContext.Provider value={value}>{children}</RecipeContext.Provider>
  );
}

export const useRecipes = () => {
  const context = useContext(RecipeContext);
  if (!context) {
    throw new Error("useRecipes must be used within RecipeProvider");
  }
  return context;
};
```

### 📄 `SidebarContext.jsx`

**Path:** `src/contexts/SidebarContext.jsx`
**Size:** 1.1 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import { createContext, useContext, useState, useEffect } from "react";
import { useLocation } from "react-router-dom";

const SidebarContext = createContext();

export const useSidebar = () => {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider");
  }
  return context;
};

export const SidebarProvider = ({ children }) => {
  const [isCollapsed, setIsCollapsed] = useState(false);
  const location = useLocation();

  // Auto-hide sidebar on recipe detail pages
  useEffect(() => {
    const isRecipeDetailPage = location.pathname.startsWith("/recipe/");
    setIsCollapsed(isRecipeDetailPage);
  }, [location.pathname]);

  const toggleSidebar = () => {
    setIsCollapsed(!isCollapsed);
  };

  const showSidebar = () => {
    setIsCollapsed(false);
  };

  const hideSidebar = () => {
    setIsCollapsed(true);
  };

  return (
    <SidebarContext.Provider
      value={{
        isCollapsed,
        toggleSidebar,
        showSidebar,
        hideSidebar,
      }}
    >
      {children}
    </SidebarContext.Provider>
  );
};
```

### 📄 `main.jsx`

**Path:** `src/main.jsx`
**Size:** 819 B
**Language:** jsx (medium confidence)
**Category:** Web Frontend
```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { ClerkProvider } from "@clerk/clerk-react";
import App from "./App.jsx";
import "./index.css";

const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!clerkPubKey) {
  throw new Error(
    "Missing Publishable Key - Add VITE_CLERK_PUBLISHABLE_KEY to your .env.local file",
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <ClerkProvider
      publishableKey={clerkPubKey}
      appearance={{
        variables: {
          colorPrimary: "#040316",
          fontFamily: '"Instrument Serif", serif',
        },
      }}
    >
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </ClerkProvider>
  </React.StrictMode>,
);
```

````
