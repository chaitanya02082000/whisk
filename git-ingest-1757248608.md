```
‚îú‚îÄ‚îÄ backend
‚îÇ   ‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes.js
‚îÇ   ‚îú‚îÄ‚îÄ models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ recipe.js
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai-recipe-parser.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debug-recpe.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fetch.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gemini.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-ai-fallback.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test.js
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chips.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chips.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hero.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hero.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ importRecipe.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recipemodal.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RecipeModal.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sidebar.css
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sidebar.jsx
‚îÇ   ‚îú‚îÄ‚îÄ contexts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RecipeContext.jsx
‚îÇ   ‚îú‚îÄ‚îÄ hooks
‚îÇ   ‚îú‚îÄ‚îÄ App.css
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ index.css
‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
‚îú‚îÄ‚îÄ eslint.config.js
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ vite.config.js
```

**Path:** `backend/app.js`  
**Size:** 976 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { url } from "./utils/config.js";
import { recipeRouter } from "./controllers/routes.js";
import express from "express";
import mongoose from "mongoose";
import cors from "cors";

const app = express();

console.log("Connecting to the db");
const connectDB = async () => {
  try {
    await mongoose.connect(url);
    console.log("Connected to MongoDB");
  } catch (error) {
    console.error("Error connecting to DB:", error.message);
  }
const validateRecipeData = (data) => {
  const errors = [];

  if (!data.name || data.name.trim() === "") {
    errors.push("Recipe name is required");
  }

  // More lenient validation - allow placeholder content
  if (!Array.isArray(data.ingredients) || data.ingredients.length === 0) {
    errors.push("Recipe must have ingredients information");
  }

  if (!Array.isArray(data.instructions) || data.instructions.length === 0) {
    errors.push("Recipe must have instructions information");
  }

  return errors;
};

recipeRouter.get("/", async (req, res) => {
  try {
    const recipes = await Recipe.find({});
    res.json(recipes);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.delete("/:id", async (request, response) => {
  try {
    const { id } = request.params;

    const deletedRecipe = await Recipe.findByIdAndDelete(id);

    if (!deletedRecipe) {
      return response.status(404).json({ error: "Recipe not found" });
    }

    response.status(204).end();
  } catch (error) {
    console.error("Error deleting recipe:", error);
    response.status(500).json({ error: error.message });
  }
});

recipeRouter.post("/parse", async (req, res) => {
  try {
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: "URL is required" });
    }

    console.log("üîç Starting recipe parsing for:", url);

    // Step 1: Try to get data from URL
    const fetchResult = await findLDJSON(url);

    // Handle blocked requests
    if (fetchResult.blocked) {
      console.log("üö´ Website blocked the request");

      // Provide manual input option
      return res.status(403).json({
        error: "Website Access Blocked",
        message: fetchResult.error,
        suggestion:
          "This website uses anti-bot protection. You can manually copy and paste the recipe content, or try a different recipe URL.",
        blockedUrl: url,
        code: "BLOCKED_BY_FIREWALL",
      });
    }

    const { jsonLd, html, $ } = fetchResult;
    let recipeData = null;
    let parsingMethod = "";

    // Step 2: Try JSON-LD first
    if (jsonLd) {
      console.log("üìã Found JSON-LD data, attempting to parse...");
      try {
        recipeData = await findRecipe(jsonLd);
        if (recipeData && recipeData.name && recipeData.name.trim() !== "") {
          parsingMethod = "JSON-LD";
          console.log("‚úÖ Successfully parsed with JSON-LD:", recipeData.name);
        } else {
          console.log("‚ö†Ô∏è JSON-LD data incomplete, trying AI...");
          recipeData = null;
        }
      } catch (error) {
        console.log("‚ö†Ô∏è JSON-LD parsing failed:", error.message);
      }
    }

    // Step 3: Fallback to AI parsing if JSON-LD failed
    if (!recipeData) {
      console.log("ü§ñ Using AI parsing...");
      try {
        const cleanHTML = extractRecipeHTML($);
        console.log("üìÑ Extracted HTML length:", cleanHTML.length);

        if (cleanHTML.length < 200) {
          throw new Error("Insufficient content extracted from webpage");
        }

        recipeData = await parseRecipeWithAI(cleanHTML, url);
        parsingMethod = "AI";
        console.log("‚úÖ AI parsing completed:", recipeData.name);
      } catch (error) {
        console.error("‚ùå AI parsing failed:", error.message);
        return res.status(422).json({
          error: "Recipe Extraction Failed",
          message:
            "Could not extract recipe content from this webpage. The page might not contain a recipe, or the content is not accessible.",
          details: error.message,
          suggestion:
            "Try a different recipe URL or manually input the recipe.",
          code: "EXTRACTION_FAILED",
        });
      }
    }

    // Step 4: Validate the parsed data
    const validationErrors = validateRecipeData(recipeData);
    if (validationErrors.length > 0) {
      console.error("‚ùå Validation failed:", validationErrors.join(", "));
      return res.status(422).json({
        error: "Incomplete Recipe Data",
        message: "The parsed recipe data is missing required fields.",
        details: validationErrors.join(", "),
        code: "VALIDATION_ERROR",
      });
    }

    // Step 5: Process and structure the data
    const processedData = {
      name: recipeData.name.trim(),
      image: recipeData.image || "",
      description: recipeData.description || `A recipe for ${recipeData.name}`,
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: Array.isArray(recipeData.category)
        ? recipeData.category
        : [recipeData.category].filter(Boolean),
      cuisine: Array.isArray(recipeData.cuisine)
        ? recipeData.cuisine
        : [recipeData.cuisine].filter(Boolean),
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url,
      parsingMethod: parsingMethod,
    };

    // Step 6: Enhance the data with another AI call
    console.log("‚ú® Enhancing recipe with AI...");
    const enhancedData = await enhanceRecipeWithAI(processedData);

    // Step 7: Save the final recipe to the database
    console.log("üíæ Saving recipe to the database...");
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing recipe:", error);
    res.status(500).json({
      error: "Server Error",
      message: "An unexpected error occurred while processing the recipe.",
      details: error.message,
    });
  }
});

// Add a new route for manual recipe input
recipeRouter.post("/manual", async (req, res) => {
  try {
    const { recipeText, url } = req.body;

    if (!recipeText) {
      return res.status(400).json({ error: "Recipe text is required" });
    }

    console.log("üìù Processing manually provided recipe text...");

    // Use AI to parse the manually provided text
    const recipeData = await parseRecipeWithAI(
      recipeText,
      url || "manual-input",
    );

    // Process and save as normal
    const processedData = {
      name: recipeData.name.trim(),
      image: recipeData.image || "",
      description: recipeData.description || "Manually added recipe",
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: Array.isArray(recipeData.category)
        ? recipeData.category
        : [recipeData.category].filter(Boolean),
      cuisine: Array.isArray(recipeData.cuisine)
        ? recipeData.cuisine
        : [recipeData.cuisine].filter(Boolean),
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url || "manual-input",
      parsingMethod: "Manual + AI",
    };

    // Enhance and save
    const enhancedData = await enhanceRecipeWithAI(processedData);
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Manual recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing manual recipe:", error);
    res.status(500).json({
      error: "Failed to process manual recipe: " + error.message,
    });
  }
});

recipeRouter.put("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const updatedRecipe = await Recipe.findByIdAndUpdate(id, updates, {
      new: true,
    });

    if (!updatedRecipe) {
      return res.status(404).json({ error: "Recipe not found" });
    }

    res.json(updatedRecipe);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.get("/:id", async (req, res) => {
  const id = req.params.id;
  const recipe = await Recipe.findById(id);
  res.json(recipe);
});

export { recipeRouter };
```

### üìÑ `index.js`

**Path:** `backend/index.js`  
**Size:** 131 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { app } from "./app.js";
import { PORT } from "./utils/config.js";
app.listen(PORT, () => console.log(`connected on the ${PORT}`));
```

### üìÑ `recipe.js`

**Path:** `backend/models/recipe.js`  
**Size:** 813 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import mongoose from "mongoose";

const recipeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  image: {
    type: String, // Changed to handle URL string or object.url
  },
  description: {
    type: String,
  },
  cookTime: {
    type: String,
  },
  prepTime: {
    type: String,
  },
  totalTime: {
    type: String,
  },
  category: {
    type: [String], // Changed to array of strings
  },
  cuisine: {
    type: [String], // Changed to array of strings
  },
  ingredients: {
    type: [String],
    required: true,
  },
  instructions: {
    type: [String],
    required: true,
  },
  yield: {
    type: String,
  },
  sourceUrl: {
    type: String,
  },
  dateAdded: {
    type: Date,
    default: Date.now,
  },
});

export const Recipe = mongoose.model("Recipe", recipeSchema);
```

### üìÑ `package.json`

**Path:** `backend/package.json`  
**Size:** 504 B  
**Language:** json (high confidence)  
**Category:** Data/Config

```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "license": "ISC",
  "author": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node --watch index.js "
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "mongodb": "^6.19.0",
    "mongoose": "^8.18.0",
    "tinyduration": "^3.4.1"
  }
}
```

### üìÑ `ai-recipe-parser.js`

**Path:** `backend/utils/ai-recipe-parser.js`  
**Size:** 6.6 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

````javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const parseRecipeWithAI = async (htmlContent, url) => {
  console.log("ü§ñ Parsing recipe with AI from HTML content...");
  console.log("üìè Content length:", htmlContent.length);

  if (htmlContent.length < 100) {
    throw new Error("Insufficient content to parse recipe");
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048,
      },
    });

    // Use more content for AI analysis
    const contentForAI =
      htmlContent.length > 12000
        ? htmlContent.substring(0, 12000) + "...[content continues]"
        : htmlContent;

    const prompt = `
Analyze this webpage content and extract recipe information. URL: ${url}

Content:
${contentForAI}

Extract recipe details and return a JSON object with this structure:
{
  "name": "Recipe Title",
  "description": "Brief description",
  "image": "image URL or empty string",
  "cookTime": "cooking time",
  "prepTime": "prep time", 
  "totalTime": "total time",
  "category": ["category1", "category2"],
  "cuisine": ["cuisine1"],
  "ingredients": ["ingredient 1 with quantity", "ingredient 2"],
  "instructions": ["step 1", "step 2", "step 3"],
  "yield": "servings"
}

IMPORTANT:
- Extract the actual recipe name from the content
- Find ALL ingredients listed (even if formatting is unclear)
- Extract ALL cooking steps/instructions
- If ingredients or instructions are not clearly listed, make reasonable assumptions based on the recipe type
- For Indian recipes, include common spices and cooking methods
- Return valid JSON only, no markdown formatting

JSON:`;

    console.log("üì§ Sending to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    console.log("üì• Raw response length:", text.length);
    console.log("üì• Response preview:", text.substring(0, 150) + "...");

    // Clean the response more thoroughly
    text = text
      .replace(/```json\s*/g, "")
      .replace(/```\s*/g, "")
      .replace(/`/g, "")
      .trim();

    // Handle case where AI might return explanation before JSON
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      text = jsonMatch[0];
    }

    let aiRecipe;
    try {
      aiRecipe = JSON.parse(text);
    } catch (parseError) {
      console.error("‚ùå JSON parse error:", parseError);
      console.log("üîç Cleaned text:", text);
      throw new Error("AI returned invalid JSON format");
    }

    // Validate and enhance the recipe data
    const validatedRecipe = {
      name: aiRecipe.name?.trim() || `Recipe from ${new URL(url).hostname}`,
      description: aiRecipe.description?.trim() || "A delicious recipe",
      image: aiRecipe.image || "",
      cookTime: aiRecipe.cookTime || "",
      prepTime: aiRecipe.prepTime || "",
      totalTime: aiRecipe.totalTime || "",
      category: Array.isArray(aiRecipe.category)
        ? aiRecipe.category
        : aiRecipe.category
          ? [aiRecipe.category]
          : ["Main Course"],
      cuisine: Array.isArray(aiRecipe.cuisine)
        ? aiRecipe.cuisine
        : aiRecipe.cuisine
          ? [aiRecipe.cuisine]
          : ["Indian"],
      ingredients:
        Array.isArray(aiRecipe.ingredients) && aiRecipe.ingredients.length > 0
          ? aiRecipe.ingredients
          : [
              "Ingredients not clearly specified - please check the original recipe",
            ],
      instructions:
        Array.isArray(aiRecipe.instructions) && aiRecipe.instructions.length > 0
          ? aiRecipe.instructions
          : [
              "Instructions not clearly specified - please check the original recipe",
            ],
      yield: aiRecipe.yield || "4 servings",
    };

    console.log("‚úÖ Validated recipe:", {
      name: validatedRecipe.name,
      ingredientsCount: validatedRecipe.ingredients.length,
      instructionsCount: validatedRecipe.instructions.length,
      hasRealIngredients: !validatedRecipe.ingredients[0]?.includes(
        "not clearly specified",
      ),
      hasRealInstructions: !validatedRecipe.instructions[0]?.includes(
        "not clearly specified",
      ),
    });

    return validatedRecipe;
  } catch (error) {
    console.error("‚ùå Error in AI parsing:", error);

    // Return a more helpful fallback
    const hostname = new URL(url).hostname;
    return {
      name: `Recipe from ${hostname}`,
      description: `Recipe from ${url} - content could not be fully extracted`,
      image: "",
      cookTime: "",
      prepTime: "",
      totalTime: "",
      category: ["Main Course"],
      cuisine: hostname.includes("indian") ? ["Indian"] : ["Unknown"],
      ingredients: [
        "Ingredients not available - please visit the original recipe",
        `Original URL: ${url}`,
      ],
      instructions: [
        "Instructions not available - please visit the original recipe",
        `Please visit: ${url}`,
      ],
      yield: "4 servings",
    };
  }
};

const enhanceRecipeWithAI = async (recipeData) => {
  console.log("üéØ Enhancing recipe:", recipeData.name);

  // Skip enhancement if the basic data is missing or is a fallback
  if (
    !recipeData.name ||
    recipeData.name.trim() === "" ||
    recipeData.ingredients[0]?.includes("not available") ||
    recipeData.instructions[0]?.includes("not available")
  ) {
    console.log("‚ö†Ô∏è Skipping enhancement - insufficient data");
    return recipeData;
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.1,
      },
    });

    const prompt = `
Improve categorization for this recipe:

Name: ${recipeData.name}
Current categories: ${JSON.stringify(recipeData.category)}
Current cuisines: ${JSON.stringify(recipeData.cuisine)}
First 3 ingredients: ${recipeData.ingredients?.slice(0, 3).join(", ")}

Return only JSON:
{
  "category": ["improved categories"],
  "cuisine": ["improved cuisines"]
}

Categories: Appetizer, Main Course, Dessert, Breakfast, Snack, Side Dish, Soup, Salad
Cuisines: Indian, Italian, Mexican, Asian, American, Mediterranean, Chinese, etc.`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    text = text
      .replace(/```json/g, "")
      .replace(/```/g, "")
      .trim();

    const enhanced = JSON.parse(text);

    return {
      ...recipeData,
      category: enhanced.category || recipeData.category,
      cuisine: enhanced.cuisine || recipeData.cuisine,
    };
  } catch (error) {
    console.error("‚ùå Enhancement failed:", error);
    return recipeData;
  }
};

export { parseRecipeWithAI, enhanceRecipeWithAI };
````

### üìÑ `config.js`

**Path:** `backend/utils/config.js`  
**Size:** 278 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
// utils/config.js
import dotenv from "dotenv";

dotenv.config(); // must be at the top-level before accessing process.env

const PORT = process.env.PORT || 3001;
const url = process.env.MONGODB_URI;
const gemini_key = process.env.GEMINI_KEY;

export { url, PORT, gemini_key };
```

### üìÑ `debug-recpe.js`

**Path:** `backend/utils/debug-recpe.js`  
**Size:** 1.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { findLDJSON, extractRecipeHTML } from "./fetch.js";
import { parseRecipeWithAI } from "./ai-recipe-parser.js";
import dotenv from "dotenv";

dotenv.config();

async function debugRecipe(url) {
  console.log("üß™ Debugging recipe parsing for:", url);

  try {
    const { jsonLd, html, $ } = await findLDJSON(url);

    if (jsonLd) {
      console.log("‚úÖ JSON-LD found:", Object.keys(jsonLd));
    } else {
      console.log("‚ùå No JSON-LD found");

      const cleanHTML = extractRecipeHTML($);
      console.log("üìÑ HTML length:", cleanHTML.length);
      console.log("üìÑ First 200 chars:", cleanHTML.substring(0, 200));

      const aiResult = await parseRecipeWithAI(cleanHTML, url);
      console.log("ü§ñ AI Result:", {
        name: aiResult.name,
        nameLength: aiResult.name?.length,
        hasIngredients: aiResult.ingredients?.length > 0,
        hasInstructions: aiResult.instructions?.length > 0,
      });
    }
  } catch (error) {
    console.error("‚ùå Debug failed:", error);
  }
}

// Test with a recipe URL
debugRecipe("https://www.recipetineats.com/chicken-breast-recipe/");
```

### üìÑ `fetch.js`

**Path:** `backend/utils/fetch.js`  
**Size:** 7.3 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import * as cheerio from "cheerio";
import * as duration from "tinyduration";

const parseInstructions = (instructions) => {
  let result = [];
  for (let instruction of instructions) {
    if (typeof instruction === "string") result.push(instruction);
    else {
      if (instruction["@type"] === "HowToStep") result.push(instruction.text);
    }
  }
  return result;
};

const findLDJSON = async (u) => {
  console.log("üåê Fetching URL with proper headers:", u);

  try {
    // Add headers to mimic a real browser
    const headers = {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      Accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
      "Accept-Language": "en-US,en;q=0.5",
      "Accept-Encoding": "gzip, deflate, br",
      Connection: "keep-alive",
      "Upgrade-Insecure-Requests": "1",
      "Sec-Fetch-Dest": "document",
      "Sec-Fetch-Mode": "navigate",
      "Sec-Fetch-Site": "none",
      "Cache-Control": "max-age=0",
    };

    let req = await fetch(u, {
      headers,
      method: "GET",
    });

    if (!req.ok) {
      throw new Error(`HTTP ${req.status}: ${req.statusText}`);
    }

    let html = await req.text();

    // Check if we got blocked by firewall
    if (
      html.includes("Sucuri Website Firewall") ||
      html.includes("Access Denied") ||
      html.includes("blocked") ||
      html.length < 1000
    ) {
      console.log("üö´ Request blocked by firewall or bot detection");
      return {
        html: null,
        $: null,
        blocked: true,
        error:
          "Website blocked the request. This site uses anti-bot protection.",
      };
    }

    let $ = cheerio.load(html);
    let jdjson = $("script[type='application/ld+json']");

    if (jdjson.length === 0) {
      console.log("üìÑ No JSON-LD found, will use HTML parsing");
      return { html, $ };
    }

    let content = JSON.parse(jdjson[0].children[0].data);

    if (Array.isArray(content)) return { jsonLd: content[0], html, $ };
    else {
      if (content["@graph"] && Array.isArray(content["@graph"])) {
        for (let t of content["@graph"]) {
          if (t["@type"] === "Recipe") return { jsonLd: t, html, $ };
        }
      }
    }
    return { html, $ };
  } catch (error) {
    console.error("‚ùå Fetch error:", error.message);
    return {
      html: null,
      $: null,
      blocked: true,
      error: `Failed to fetch: ${error.message}`,
    };
  }
};

const durationToStr = (d) => {
  if (!d) return "";
  let parsed = duration.parse(d);
  let result = [];
  if (parsed.hours) {
    result.push(`${parsed.hours} hours`);
  }
  if (parsed.minutes) {
    result.push(`${parsed.minutes} minutes`);
  }
  if (parsed.seconds) {
    result.push(`${parsed.seconds} seconds`);
  }

  let formatter = new Intl.ListFormat("en", {
    style: "long",
    type: "conjunction",
  });
  return formatter.format(result);
};

const findRecipe = async (jdjson) => {
  if (jdjson["@type"].indexOf("Recipe") === -1) return;

  let result = {};
  result.name = jdjson["name"];
  result.image = jdjson["image"];
  result.description = jdjson["description"];
  result.cookTime = durationToStr(jdjson["cookTime"]);
  result.prepTime = durationToStr(jdjson["prepTime"]);
  result.totalTime = durationToStr(jdjson["totalTime"]);
  result.category = jdjson["recipeCategory"] ?? "";
  result.cuisine = jdjson["recipeCuisine"] ?? "";
  result.ingredients = jdjson["recipeIngredient"];
  result.instructions = parseInstructions(jdjson["recipeInstructions"]);
  result.yield = jdjson["recipeYield"][0];

  return result;
};

const extractRecipeHTML = ($) => {
  if (!$) {
    return "No content available";
  }

  console.log("üîç Extracting recipe content from HTML...");

  // Remove unwanted elements first
  $(
    "script, style, nav, header, footer, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation",
  ).remove();

  let recipeContent = "";
  let contentFound = false;

  // Try multiple strategies to find recipe content
  const strategies = [
    // Strategy 1: Look for recipe-specific selectors
    () => {
      const selectors = [
        '[itemtype*="Recipe"]',
        ".recipe-card",
        ".recipe-content",
        ".recipe-post",
        ".recipe-container",
        ".recipe",
        ".entry-recipe",
        ".post-recipe",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìã Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 2: Look for main content areas
    () => {
      const selectors = [
        "main",
        "article",
        ".entry-content",
        ".post-content",
        ".content",
        "#content",
        ".main-content",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìÑ Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 3: Look for specific content patterns
    () => {
      // Look for elements containing recipe keywords
      const recipeKeywords = [
        "ingredients",
        "instructions",
        "directions",
        "recipe",
        "cook",
        "prep",
      ];
      let bestElement = null;
      let maxScore = 0;

      $("div, section, article").each((i, elem) => {
        const $elem = $(elem);
        const text = $elem.text().toLowerCase();
        let score = 0;

        recipeKeywords.forEach((keyword) => {
          if (text.includes(keyword)) score++;
        });

        if (score > maxScore && $elem.text().length > 200) {
          maxScore = score;
          bestElement = $elem;
        }
      });

      if (bestElement) {
        console.log(
          `üéØ Found content with keyword matching (score: ${maxScore})`,
        );
        return bestElement.html();
      }
      return null;
    },

    // Strategy 4: Fallback to body content
    () => {
      console.log("üì¶ Using full body content as fallback");
      return $("body").html();
    },
  ];

  // Try each strategy until we find content
  for (const strategy of strategies) {
    const content = strategy();
    if (content && content.length > 100) {
      // Minimum content length
      recipeContent = content;
      contentFound = true;
      break;
    }
  }

  if (!contentFound) {
    console.log("‚ùå No substantial content found");
    return "No recipe content found";
  }

  // Clean up the extracted content
  const cleanedContent = cheerio.load(recipeContent);

  // Remove more unwanted elements from the extracted content
  cleanedContent(
    "script, style, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation, .popup, .modal",
  ).remove();

  // Get text content and clean it up
  let textContent = cleanedContent.text();

  // Clean up whitespace and formatting
  textContent = textContent
    .replace(/\s+/g, " ") // Replace multiple whitespace with single space
    .replace(/\n\s*\n/g, "\n") // Remove empty lines
    .trim();

  console.log(`üìè Extracted content length: ${textContent.length} characters`);

  return textContent;
};

export { findLDJSON, findRecipe, extractRecipeHTML };
```

### üìÑ `gemini.js`

**Path:** `backend/utils/gemini.js`  
**Size:** 3.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

````javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const enhanceRecipeWithAI = async (recipeData) => {
  console.log("ü§ñ Starting AI enhancement for recipe:", recipeData.name);
  console.log("üìä Original data:", {
    category: recipeData.category,
    cuisine: recipeData.cuisine,
    ingredients: recipeData.ingredients?.slice(0, 3), // Just first 3 for logging
  });

  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    const prompt = `
Please analyze this recipe data and provide better categorization and cataloguing. 
Return ONLY a valid JSON object (no markdown, no code blocks, no additional text).

Expected format:
{
  "category": ["array", "of", "categories"],
  "cuisine": ["array", "of", "cuisines"],
  "name": "improved recipe name if needed",
  "description": "improved description if needed"
}

Recipe data to analyze:
Name: ${recipeData.name}
Description: ${recipeData.description}
Ingredients: ${recipeData.ingredients?.join(", ")}
Instructions: ${recipeData.instructions?.slice(0, 3).join(". ")}
Original Category: ${recipeData.category}
Original Cuisine: ${recipeData.cuisine}

Focus on:
- Better food categories (e.g., "Dessert", "Main Course", "Appetizer", "Breakfast", "Snack")
- More specific cuisine types (e.g., "Italian", "Mexican", "Asian", "Mediterranean")
- Keep the same name and description unless they need minor improvements

IMPORTANT: Return ONLY the JSON object, no other text or formatting.
`;

    console.log("üì§ Sending prompt to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    console.log("üì• Raw AI response:", text);

    // Clean the response to extract JSON
    text = text.trim();

    // Remove markdown code blocks if present
    if (text.startsWith("```json")) {
      text = text.replace(/^```json\s*/, "").replace(/\s*```$/, "");
    } else if (text.startsWith("```")) {
      text = text.replace(/^```\s*/, "").replace(/\s*```$/, "");
    }

    // Remove any remaining backticks
    text = text.replace(/`/g, "");

    console.log("üßπ Cleaned response:", text);

    // Parse the AI response
    const aiEnhancements = JSON.parse(text.trim());
    console.log("‚úÖ Parsed AI enhancements:", aiEnhancements);

    const enhancedData = {
      ...recipeData,
      category: aiEnhancements.category || recipeData.category,
      cuisine: aiEnhancements.cuisine || recipeData.cuisine,
      name: aiEnhancements.name || recipeData.name,
      description: aiEnhancements.description || recipeData.description,
    };

    console.log("üéØ Final enhanced data:", {
      category: enhancedData.category,
      cuisine: enhancedData.cuisine,
      nameChanged: enhancedData.name !== recipeData.name,
      descriptionChanged: enhancedData.description !== recipeData.description,
    });

    return enhancedData;
  } catch (error) {
    console.error("‚ùå Error enhancing recipe with AI:", error);
    console.log("üîÑ Falling back to original data");
    // Return original data if AI processing fails
    return recipeData;
  }
};

export { enhanceRecipeWithAI };
````

### üìÑ `test-ai-fallback.js`

**Path:** `backend/utils/test-ai-fallback.js`  
**Size:** 1.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { findLDJSON, findRecipe, extractRecipeHTML } from "./fetch.js";
import { parseRecipeWithAI } from "./ai-recipe-parser.js";
import dotenv from "dotenv";

dotenv.config();

// Test URLs - one with JSON-LD and one without
const testUrls = [
  "https://www.allrecipes.com/recipe/10275/classic-peanut-butter-cookies/", // Has JSON-LD
  "https://www.food.com/recipe/simple-chocolate-chip-cookies-16589", // May not have JSON-LD
];

async function testBothMethods() {
  for (const url of testUrls) {
    console.log(`\nüß™ Testing: ${url}`);

    try {
      // Try JSON-LD first
      const { jsonLd, html, $ } = await findLDJSON(url);

      if (jsonLd) {
        console.log("‚úÖ JSON-LD found");
        const recipe = await findRecipe(jsonLd);
        if (recipe) {
          console.log("‚úÖ JSON-LD parsing successful:", recipe.name);
        }
      } else {
        console.log("‚ö†Ô∏è No JSON-LD found, trying AI...");
        const cleanHTML = extractRecipeHTML($);
        const aiRecipe = await parseRecipeWithAI(cleanHTML, url);
        console.log("‚úÖ AI parsing successful:", aiRecipe.name);
      }
    } catch (error) {
      console.error("‚ùå Error:", error.message);
    }
  }
}

testBothMethods();
```

### üìÑ `test.js`

**Path:** `backend/utils/test.js`  
**Size:** 1.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { enhanceRecipeWithAI } from "./gemini.js";
import dotenv from "dotenv";

dotenv.config();

const testRecipe = {
  name: "Chocolate Chip Cookies",
  description: "Classic homemade cookies",
  category: ["Cookies"],
  cuisine: ["American"],
  ingredients: [
    "2 cups all-purpose flour",
    "1 cup butter",
    "1 cup brown sugar",
    "2 eggs",
    "1 tsp vanilla",
    "1 cup chocolate chips",
  ],
  instructions: [
    "Preheat oven to 375¬∞F",
    "Mix butter and sugar",
    "Add eggs and vanilla",
    "Mix in flour",
    "Fold in chocolate chips",
    "Bake for 12 minutes",
  ],
};

async function testAI() {
  console.log("üß™ Testing AI enhancement...");
  console.log("üìã Original recipe:", testRecipe);

  try {
    const enhanced = await enhanceRecipeWithAI(testRecipe);
    console.log("‚úÖ Enhanced recipe:", enhanced);

    // Check if categories changed
    const categoriesChanged =
      JSON.stringify(enhanced.category) !== JSON.stringify(testRecipe.category);
    const cuisineChanged =
      JSON.stringify(enhanced.cuisine) !== JSON.stringify(testRecipe.cuisine);

    console.log("üìä Changes detected:");
    console.log(`  Categories changed: ${categoriesChanged}`);
    console.log(`  Cuisine changed: ${cuisineChanged}`);

    if (categoriesChanged || cuisineChanged) {
      console.log("üéâ AI is working! Data was enhanced.");
    } else {
      console.log("‚ö†Ô∏è No changes detected. Check AI prompt or API connection.");
    }
  } catch (error) {
    console.error("‚ùå Test failed:", error);
  }
}

testAI();
```

### üìÑ `eslint.config.js`

**Path:** `eslint.config.js`  
**Size:** 763 B  
**Language:** javascript (high confidence)  
**Category:** Web Frontend

```javascript
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
  globalIgnores(["dist"]),
  {
    files: ["**/*.{js,jsx}"],
    extends: [
      js.configs.recommended,
      reactHooks.configs["recommended-latest"],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: "latest",
        ecmaFeatures: { jsx: true },
        sourceType: "module",
      },
    },
    rules: {
      "no-unused-vars": ["error", { varsIgnorePattern: "^[A-Z_]" }],
    },
  },
]);
```

### üìÑ `index.html`

**Path:** `index.html`  
**Size:** 871 B  
**Language:** html (medium confidence)  
**Category:** Web Frontend

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&display=swap"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&display=swap"
        rel="stylesheet"
      />
    </noscript>

    <title>Whisk</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

### üìÑ `package.json`

**Path:** `package.json`  
**Size:** 626 B  
**Language:** json (high confidence)  
**Category:** Data/Config

```json
{
  "name": "whisk",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "vite": "^7.1.2"
  }
}
```

### üìÑ `App.jsx`

**Path:** `src/App.jsx`  
**Size:** 423 B  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import Hero from "./components/hero";
import "./App.css";
import Sidebar from "./components/sidebar";
import { RecipeProvider } from "./contexts/RecipeContext";

function App() {
  return (
    <>
      <RecipeProvider>
        <div className="main">
          <Sidebar />
          <main className="content">
            <Hero />
          </main>
        </div>
      </RecipeProvider>
    </>
  );
}
export default App;
```

### üìÑ `RecipeModal.jsx`

**Path:** `src/components/RecipeModal.jsx`  
**Size:** 2.9 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import React from "react";
import "./recipemodal.css";

const RecipeModal = ({ recipe, isOpen, onClose }) => {
  if (!isOpen || !recipe) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>{recipe.name}</h2>
          <button className="close-button" onClick={onClose}>
            √ó
          </button>
        </div>

        <div className="modal-body">
          {recipe.image && (
            <img
              src={recipe.image}
              alt={recipe.name}
              className="recipe-detail-image"
            />
          )}

          <div className="recipe-meta">
            <div className="time-info">
              {recipe.prepTime && <span>Prep: {recipe.prepTime}</span>}
              {recipe.cookTime && <span>Cook: {recipe.cookTime}</span>}
              {recipe.totalTime && <span>Total: {recipe.totalTime}</span>}
            </div>

            <div className="recipe-tags">
              {recipe.category?.map((cat, index) => (
                <span key={index} className="tag category-tag">
                  {cat}
                </span>
              ))}
              {recipe.cuisine?.map((cuisine, index) => (
                <span key={index} className="tag cuisine-tag">
                  {cuisine}
                </span>
              ))}
            </div>
          </div>

          {recipe.description && (
            <div className="recipe-description">
              <h3>Description</h3>
              <p>{recipe.description}</p>
            </div>
          )}

          <div className="recipe-details">
            <div className="ingredients-section">
              <h3>Ingredients</h3>
              <ul className="ingredients-list">
                {recipe.ingredients?.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>

            <div className="instructions-section">
              <h3>Instructions</h3>
              <ol className="instructions-list">
                {recipe.instructions?.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {recipe.yield && (
            <div className="recipe-yield">
              <strong>Serves: {recipe.yield}</strong>
            </div>
          )}

          {recipe.sourceUrl && (
            <div className="recipe-source">
              <a
                href={recipe.sourceUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="source-link"
              >
                View Original Recipe
              </a>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default RecipeModal;
```

### üìÑ `card.jsx`

**Path:** `src/components/card.jsx`  
**Size:** 1.3 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
const Card = ({ heading, summary, recipe, onClick }) => {
  const handleClick = () => {
    if (onClick) {
      onClick(recipe);
    }
  };

  return (
    <div className="recipe-card" onClick={handleClick}>
      <h2>{heading}</h2>

      {summary && <p>{summary}</p>}

      {/* Time information */}
      {(recipe.prepTime || recipe.cookTime || recipe.totalTime) && (
        <div className="time">
          {recipe.prepTime && (
            <div>
              <span>Prep: {recipe.prepTime}</span>
            </div>
          )}
          {recipe.cookTime && (
            <div>
              <span>Cook: {recipe.cookTime}</span>
            </div>
          )}
          {recipe.totalTime && (
            <div>
              <span>Total: {recipe.totalTime}</span>
            </div>
          )}
        </div>
      )}

      {/* Categories */}
      {(recipe.category?.length > 0 || recipe.cuisine?.length > 0) && (
        <div className="categories">
          {recipe.category?.slice(0, 3).map((cat, index) => (
            <span key={index} className="category-tag">
              {cat}
            </span>
          ))}
          {recipe.cuisine?.slice(0, 2).map((cuisine, index) => (
            <span key={index} className="category-tag">
              {cuisine}
            </span>
          ))}
        </div>
      )}
    </div>
  );
};

export default Card;
```

### üìÑ `chips.jsx`

**Path:** `src/components/chips.jsx`  
**Size:** 2.9 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import { useState, useEffect } from "react";
import { useRecipes } from "../contexts/RecipeContext";
import "./chips.css";

const Chips = ({ onChipsChange }) => {
  const [text, setText] = useState("");
  const [chips, setChips] = useState([]);
  const [availableTags, setAvailableTags] = useState([]);

  const { recipes } = useRecipes();

  useEffect(() => {
    if (recipes.length > 0) {
      const categories = recipes.flatMap((recipe) => recipe.category || []);
      const cuisines = recipes.flatMap((recipe) => recipe.cuisine || []);
      const allTags = [...new Set([...categories, ...cuisines])];
      setAvailableTags(allTags);
    }
  }, [recipes]);

  useEffect(() => {
    if (onChipsChange) {
      onChipsChange(chips);
    }
  }, [chips, onChipsChange]);

  const handleKey = (e) => {
    if (e.key === "Enter" && text.trim()) {
      e.preventDefault();
      if (!chips.includes(text.trim())) {
        setChips((prev) => [...prev, text.trim()]);
      }
      setText("");
    }
  };

  const removeChip = (indexToRemove) => {
    setChips(chips.filter((_, index) => index !== indexToRemove));
  };

  const addTagChip = (tag) => {
    if (!chips.includes(tag)) {
      setChips((prev) => [...prev, tag]);
    }
  };

  const clearAllChips = () => {
    setChips([]);
  };

  return (
    <div className="chips-container">
      <input
        className="chips-input"
        value={text}
        onChange={(e) => setText(e.target.value)}
        onKeyDown={handleKey}
        placeholder="Add custom tags... (Press Enter)"
      />

      {availableTags.length > 0 && (
        <div className="chips-section">
          <div className="chips-section-header">
            <h4 className="chips-section-title">
              Available from your recipes:
            </h4>
            {chips.length > 0 && (
              <button className="chips-clear-button" onClick={clearAllChips}>
                Clear all
              </button>
            )}
          </div>
          <div className="chips-available">
            {availableTags.map((tag, index) => (
              <button
                key={index}
                className="chip-available"
                onClick={() => addTagChip(tag)}
                disabled={chips.includes(tag)}
              >
                {tag}
              </button>
            ))}
          </div>
        </div>
      )}

      {chips.length > 0 && (
        <div className="chips-section">
          <h4 className="chips-section-title">Active filters:</h4>
          <div className="chips-selected">
            {chips.map((chip, index) => (
              <div key={index} className="chip-selected">
                {chip}
                <button
                  className="chip-remove-button"
                  onClick={() => removeChip(index)}
                >
                  √ó
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default Chips;
```

### üìÑ `hero.jsx`

**Path:** `src/components/hero.jsx`  
**Size:** 5.7 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import { useEffect, useState } from "react";
import "./hero.css";
import Chips from "./chips";
import Card from "./card";
import RecipeModal from "./RecipeModal"; // Add this import
import { useRecipes } from "../contexts/RecipeContext";

const Hero = () => {
  const [search, setSearch] = useState("");
  const [filteredRecipes, setFilteredRecipes] = useState([]);
  const [selectedChips, setSelectedChips] = useState([]);
  const [category, setCategory] = useState("");
  const [cuisine, setCuisine] = useState("");

  // Add modal state
  const [selectedRecipe, setSelectedRecipe] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);

  // Get data and functions from context
  const { recipes, loading, error } = useRecipes();

  const inputWidth = `${Math.max(30, search.length + 2)}ch`;

  // Update filtered recipes when recipes change
  useEffect(() => {
    setFilteredRecipes(recipes);
  }, [recipes]);

  // Filter recipes based on search, category, and cuisine
  useEffect(() => {
    let filtered = recipes;

    if (search) {
      filtered = filtered.filter(
        (recipe) =>
          recipe.name.toLowerCase().includes(search.toLowerCase()) ||
          recipe.description?.toLowerCase().includes(search.toLowerCase()),
      );
    }

    if (category) {
      filtered = filtered.filter((recipe) =>
        recipe.category?.includes(category),
      );
    }

    if (cuisine) {
      filtered = filtered.filter((recipe) => recipe.cuisine?.includes(cuisine));
    }

    // Filter by selected chips
    if (selectedChips.length > 0) {
      filtered = filtered.filter((recipe) => {
        const recipeTags = [
          ...(recipe.category || []),
          ...(recipe.cuisine || []),
        ];
        return selectedChips.some((chip) => recipeTags.includes(chip));
      });
    }

    setFilteredRecipes(filtered);
  }, [search, category, cuisine, selectedChips, recipes]);

  // Add modal handlers
  const handleRecipeClick = (recipe) => {
    setSelectedRecipe(recipe);
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setSelectedRecipe(null);
  };

  // Handle keyboard navigation for modal
  useEffect(() => {
    const handleEscape = (event) => {
      if (event.key === "Escape") {
        handleCloseModal();
      }
    };

    if (isModalOpen) {
      document.addEventListener("keydown", handleEscape);
      document.body.style.overflow = "hidden"; // Prevent background scroll
    }

    return () => {
      document.removeEventListener("keydown", handleEscape);
      document.body.style.overflow = "unset";
    };
  }, [isModalOpen]);

  const handleCategoryChange = (e) => {
    setCategory(e.target.value);
  };

  const handleCuisineChange = (e) => {
    setCuisine(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
  };

  // Extract unique categories and cuisines for dropdowns
  const categories = [
    ...new Set(recipes.flatMap((recipe) => recipe.category || [])),
  ];
  const cuisines = [
    ...new Set(recipes.flatMap((recipe) => recipe.cuisine || [])),
  ];

  // Handle loading state
  if (loading) {
    return (
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Loading recipes...</h2>
        </div>
      </div>
    );
  }

  // Handle error state
  if (error) {
    return (
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Error: {error}</h2>
        </div>
      </div>
    );
  }

  return (
    <>
      <div className="hero">
        <div className="header">
          <h1>Whisk</h1>
          <h2>Discover, Organize, and cook your favourite recipes.</h2>
        </div>
        <div className="search">
          <form onSubmit={handleSubmit}>
            <input
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder="Search recipes or ask questions(eg., 'Show me a quick dinner recipe.')"
              style={{ width: inputWidth, height: "3em" }}
            />
          </form>
          <div className="dropdown">
            <select
              className="dropdown-1"
              value={category}
              onChange={handleCategoryChange}
            >
              <option value="">All Categories</option>
              {categories.map((cat) => (
                <option key={cat} value={cat}>
                  {cat}
                </option>
              ))}
            </select>
            <select
              className="dropdown-2"
              value={cuisine}
              onChange={handleCuisineChange}
            >
              <option value="">All Cuisines</option>
              {cuisines.map((cui) => (
                <option key={cui} value={cui}>
                  {cui}
                </option>
              ))}
            </select>
          </div>
          <Chips onChipsChange={setSelectedChips} />
        </div>
      </div>

      {/* Recipes display section */}
      <div className="recipes-grid">
        {filteredRecipes.length > 0 ? (
          filteredRecipes.map((recipe) => (
            <Card
              key={recipe._id}
              heading={recipe.name}
              summary={recipe.description}
              recipe={recipe}
              onClick={handleRecipeClick} // Pass the click handler to Card
            />
          ))
        ) : (
          <div className="no-recipes">
            <h3>No recipes found</h3>
            <p>Try adjusting your search terms or filters to find recipes.</p>
          </div>
        )}
      </div>

      {/* Add the modal here */}
      <RecipeModal
        recipe={selectedRecipe}
        isOpen={isModalOpen}
        onClose={handleCloseModal}
      />
    </>
  );
};

export default Hero;
```

### üìÑ `importRecipe.jsx`

**Path:** `src/components/importRecipe.jsx`  
**Size:** 1.4 KB  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

```jsx
import { useState } from "react";
import { useRecipes } from "../contexts/RecipeContext";

import "./sidebar.css";
const Button = ({ children, onSuccess, onError }) => {
  const [recipeUrl, setRecipeUrl] = useState("");
  const [loading, setLoading] = useState(false);

  // Use the parseAndAddRecipe function from context
  const { parseAndAddRecipe } = useRecipes();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!recipeUrl) {
      alert("Please enter a recipe URL");
      return;
    }

    setLoading(true);
    console.log("Submitting URL:", recipeUrl);
    try {
      const recipe = await parseAndAddRecipe(recipeUrl);
      console.log("Recipe parsed and added:", recipe);
      setLoading(false);
      setRecipeUrl("");

      if (onSuccess) {
        onSuccess(recipe);
      }
    } catch (error) {
      setLoading(false);
      console.error("Error parsing recipe:", error);
      if (onError) {
        onError(error);
      }
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={recipeUrl}
        onChange={(e) => setRecipeUrl(e.target.value)}
        placeholder="Paste recipe URL here"
        className="recipe-input"
      />
      <button className="sidebar-button" type="submit" disabled={loading}>
        {loading ? "Processing..." : children || "Parse Recipe"}
      </button>
    </form>
  );
};

export default Button;
```

**Path:** `src/components/sidebar.jsx`  
**Size:** 296 B  
**Language:** jsx (medium confidence)  
**Category:** Web Frontend

export default Sidebar;

````

### üìÑ `RecipeContext.jsx`

**Path:** `src/contexts/RecipeContext.jsx`
**Size:** 3.2 KB
**Language:** jsx (medium confidence)
**Category:** Web Frontend

```jsx
import React, { createContext, useContext, useState, useEffect } from "react";
import axios from "axios";

const URL = import.meta.env.VITE_URL;
const RecipeContext = createContext();

export const useRecipes = () => {
  const context = useContext(RecipeContext);
  if (!context) {
    throw new Error("useRecipes must be used within a RecipeProvider");
  }
  return context;
};

export const RecipeProvider = ({ children }) => {
  const [recipes, setRecipes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch all recipes
  const fetchRecipes = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await axios.get(URL);
      setRecipes(response.data);
    } catch (error) {
      console.error("Error fetching recipes:", error);
      setError("Failed to fetch recipes");
    } finally {
      setLoading(false);
    }
  };

  // Parse recipe from URL and add it
  const parseAndAddRecipe = async (url) => {
    console.log("Parsing URL:", url);
    try {
      const response = await axios.post(`${URL}parse`, { url });
      console.log("API response:", response.data);
      // Immediately update the local state
      setRecipes((prevRecipes) => [...prevRecipes, response.data]);
      return response.data;
    } catch (error) {
      console.error("Error parsing recipe:", error);
      setError("Failed to parse recipe");
      throw error;
    }
  };

  // Add a new recipe (manual entry)
  const addRecipe = async (newRecipe) => {
    try {
      const response = await axios.post(URL, newRecipe);
      setRecipes((prevRecipes) => [...prevRecipes, response.data]);
      return response.data;
    } catch (error) {
      console.error("Error adding recipe:", error);
      setError("Failed to add recipe");
      throw error;
    }
  };

  // Update an existing recipe
  const updateRecipe = async (id, updatedRecipe) => {
    console.log("Updating recipe:", id, updatedRecipe);
    try {
      const response = await axios.put(`${URL}${id}`, updatedRecipe);
      console.log("Update response:", response.data);
      setRecipes((prevRecipes) =>
        prevRecipes.map((recipe) =>
          recipe._id === id ? response.data : recipe,
        ),
      );
      return response.data;
    } catch (error) {
      console.error("Error updating recipe:", error);
      setError("Failed to update recipe");
      throw error;
    }
  };

  // Delete a recipe
  const deleteRecipe = async (id) => {
    try {
      await axios.delete(`${URL}${id}`);
      setRecipes((prevRecipes) =>
        prevRecipes.filter((recipe) => recipe._id !== id),
      );
    } catch (error) {
      console.error("Error deleting recipe:", error);
      setError("Failed to delete recipe");
      throw error;
    }
  };

  // Refresh recipes (manual refresh)
  const refreshRecipes = () => {
    fetchRecipes();
  };

  // Initial fetch on mount
  useEffect(() => {
    fetchRecipes();
  }, []);

  const value = {
    recipes,
    loading,
    error,
    fetchRecipes,
    parseAndAddRecipe, // Add this new function
    addRecipe,
    updateRecipe,
    deleteRecipe,
    refreshRecipes,
  };

  return (
    <RecipeContext.Provider value={value}>{children}</RecipeContext.Provider>
  );
};
````
