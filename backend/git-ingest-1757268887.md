```
‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îú‚îÄ‚îÄ chat.js
‚îÇ   ‚îî‚îÄ‚îÄ routes.js
‚îú‚îÄ‚îÄ models
‚îÇ   ‚îú‚îÄ‚îÄ notes.js
‚îÇ   ‚îî‚îÄ‚îÄ recipe.js
‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îú‚îÄ‚îÄ ai-recipe-parser.js
‚îÇ   ‚îú‚îÄ‚îÄ config.js
‚îÇ   ‚îú‚îÄ‚îÄ debug-recpe.js
‚îÇ   ‚îú‚îÄ‚îÄ fetch.js
‚îÇ   ‚îú‚îÄ‚îÄ gemini.js
‚îÇ   ‚îú‚îÄ‚îÄ recipe-chat-ai.js
‚îÇ   ‚îú‚îÄ‚îÄ test-ai-fallback.js
‚îÇ   ‚îî‚îÄ‚îÄ test.js
‚îú‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ package.json
```

## üìÅ Files by Category

### üåê Web Frontend

**Languages:** javascript  
**File Count:** 14

### ‚öôÔ∏è Data/Config

**Languages:** json  
**File Count:** 1

## üìã Complete File Listing

The following section contains the complete content of all text files in the project,
organized with proper syntax highlighting and metadata for optimal LLM processing.

### üìÑ `app.js`

**Path:** `app.js`  
**Size:** 1.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { url } from "./utils/config.js";
import { recipeRouter } from "./controllers/routes.js";
import { chatRouter } from "./controllers/chat.js";
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import "dotenv/config";
const app = express();

console.log("Connecting to the db");
const connectDB = async () => {
  try {
    await mongoose.connect(url);
    console.log("Connected to MongoDB");
  } catch (error) {
    console.error("Error connecting to DB:", error.message);
    process.exit(1); // Exit if database connection fails
  }
};

connectDB();

// Middleware
app.use(cors());
app.use(express.json());

// API routes - Fixed routing conflict
app.use("/api/recipes", recipeRouter);
app.use("/api/chat", chatRouter); // Changed to different path

// Error handler middleware
app.use((error, request, response, next) => {
  console.error(error.message);

  if (error.name === "CastError") {
    return response.status(400).send({ error: "Malformatted ID" });
  } else if (error.name === "ValidationError") {
    return response.status(400).json({ error: error.message });
  }

  next(error);
});

export { app };
```

### üìÑ `chat.js`

**Path:** `controllers/chat.js`  
**Size:** 3.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { Router } from "express";
import { Note } from "../models/notes.js"; // Fixed import path
import { Recipe } from "../models/recipe.js";
import { chatWithRecipeAI } from "../utils/recipe-chat-ai.js";

const chatRouter = Router();

// Get all notes/chats for a recipe - Updated route
chatRouter.get("/recipes/:recipeId/notes", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const notes = await Note.find({ recipeId }).sort({ timestamp: 1 });
    res.json(notes);
  } catch (error) {
    console.error("Error fetching notes:", error);
    res.status(500).json({ error: error.message });
  }
});

// Save a note - Updated route
chatRouter.post("/recipes/:recipeId/notes", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const { content, type } = req.body;

    if (!content || !type) {
      return res.status(400).json({ error: "Content and type are required" });
    }

    const note = new Note({
      recipeId,
      content,
      type,
      isFromAI: false,
    });

    const savedNote = await note.save();
    res.status(201).json(savedNote);
  } catch (error) {
    console.error("Error saving note:", error);
    res.status(500).json({ error: error.message });
  }
});
chatRouter.delete("/recipes/:recipeId/chat", async (req, res) => {
  try {
    const { recipeId } = req.params;

    // Delete only chat messages for this recipe (keep notes)
    const result = await Note.deleteMany({
      recipeId,
      type: "chat",
    });

    res.json({
      message: `Cleared ${result.deletedCount} chat messages`,
      deletedCount: result.deletedCount,
    });
  } catch (error) {
    console.error("Error clearing chat history:", error);
    res.status(500).json({ error: error.message });
  }
});
// Chat with AI about a recipe - Updated route
chatRouter.post("/recipes/:recipeId/chat", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const { message } = req.body;

    if (!message) {
      return res.status(400).json({ error: "Message is required" });
    }

    // Get the recipe data
    const recipe = await Recipe.findById(recipeId);
    if (!recipe) {
      return res.status(404).json({ error: "Recipe not found" });
    }

    // Save user message
    const userNote = new Note({
      recipeId,
      content: message,
      type: "chat",
      isFromAI: false,
    });
    await userNote.save();

    // Get AI response
    const aiResponse = await chatWithRecipeAI(recipe, message);

    // FIX: Ensure we save a string, not an object
    let aiContent;
    if (typeof aiResponse === "object") {
      // If it's an object, stringify it or extract the main response
      aiContent = aiResponse.response || JSON.stringify(aiResponse);
    } else {
      aiContent = aiResponse;
    }

    // Save AI response
    const aiNote = new Note({
      recipeId,
      content: aiContent, // Now guaranteed to be a string
      type: "chat",
      isFromAI: true,
    });
    await aiNote.save();

    res.json({
      userMessage: userNote,
      aiResponse: aiNote,
    });
  } catch (error) {
    console.error("Error in chat:", error);
    res.status(500).json({ error: error.message });
  }
});

// Delete a note
chatRouter.delete("/notes/:noteId", async (req, res) => {
  try {
    const { noteId } = req.params;
    await Note.findByIdAndDelete(noteId);
    res.status(204).end();
  } catch (error) {
    console.error("Error deleting note:", error);
    res.status(500).json({ error: error.message });
  }
});

export { chatRouter };
```

### üìÑ `routes.js`

**Path:** `controllers/routes.js`  
**Size:** 9.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { response, Router } from "express";
import { Recipe } from "../models/recipe.js";
import { findLDJSON, findRecipe, extractRecipeHTML } from "../utils/fetch.js";
import {
  parseRecipeWithAI,
  enhanceRecipeWithAI,
} from "../utils/ai-recipe-parser.js";

const recipeRouter = Router();
const sanitizeRecipeData = (data) => {
  return {
    ...data,
    image: typeof data.image === "string" ? data.image : data.image?.url || "",
    name: typeof data.name === "string" ? data.name.trim() : "",
    description:
      typeof data.description === "string" ? data.description.trim() : "",
    cookTime: typeof data.cookTime === "string" ? data.cookTime : "",
    prepTime: typeof data.prepTime === "string" ? data.prepTime : "",
    totalTime: typeof data.totalTime === "string" ? data.totalTime : "",
    yield:
      typeof data.yield === "string"
        ? data.yield
        : Array.isArray(data.yield)
          ? data.yield[0]
          : "",
    category: Array.isArray(data.category)
      ? data.category
      : data.category
        ? [data.category]
        : [],
    cuisine: Array.isArray(data.cuisine)
      ? data.cuisine
      : data.cuisine
        ? [data.cuisine]
        : [],
    ingredients: Array.isArray(data.ingredients) ? data.ingredients : [],
    instructions: Array.isArray(data.instructions) ? data.instructions : [],
  };
};
// Validation function
const validateRecipeData = (data) => {
  const errors = [];

  if (!data.name || data.name.trim() === "") {
    errors.push("Recipe name is required");
  }

  // More lenient validation - allow placeholder content
  if (!Array.isArray(data.ingredients) || data.ingredients.length === 0) {
    errors.push("Recipe must have ingredients information");
  }

  if (!Array.isArray(data.instructions) || data.instructions.length === 0) {
    errors.push("Recipe must have instructions information");
  }

  return errors;
};

recipeRouter.get("/", async (req, res) => {
  try {
    const recipes = await Recipe.find({});
    res.json(recipes);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.delete("/:id", async (request, response) => {
  try {
    const { id } = request.params;

    const deletedRecipe = await Recipe.findByIdAndDelete(id);

    if (!deletedRecipe) {
      return response.status(404).json({ error: "Recipe not found" });
    }

    response.status(204).end();
  } catch (error) {
    console.error("Error deleting recipe:", error);
    response.status(500).json({ error: error.message });
  }
});

recipeRouter.post("/parse", async (req, res) => {
  try {
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: "URL is required" });
    }

    console.log("üîç Starting recipe parsing for:", url);

    // Step 1: Try to get data from URL
    const fetchResult = await findLDJSON(url);

    // Handle blocked requests
    if (fetchResult.blocked) {
      console.log("üö´ Website blocked the request");

      // Provide manual input option
      return res.status(403).json({
        error: "Website Access Blocked",
        message: fetchResult.error,
        suggestion:
          "This website uses anti-bot protection. You can manually copy and paste the recipe content, or try a different recipe URL.",
        blockedUrl: url,
        code: "BLOCKED_BY_FIREWALL",
      });
    }

    const { jsonLd, html, $ } = fetchResult;
    let recipeData = null;
    let parsingMethod = "";

    // Step 2: Try JSON-LD first
    if (jsonLd) {
      console.log("üìã Found JSON-LD data, attempting to parse...");
      try {
        recipeData = await findRecipe(jsonLd);
        if (recipeData && recipeData.name && recipeData.name.trim() !== "") {
          parsingMethod = "JSON-LD";
          console.log("‚úÖ Successfully parsed with JSON-LD:", recipeData.name);
        } else {
          console.log("‚ö†Ô∏è JSON-LD data incomplete, trying AI...");
          recipeData = null;
        }
      } catch (error) {
        console.log("‚ö†Ô∏è JSON-LD parsing failed:", error.message);
      }
    }

    // Step 3: Fallback to AI parsing if JSON-LD failed
    if (!recipeData) {
      console.log("ü§ñ Using AI parsing...");
      try {
        const cleanHTML = extractRecipeHTML($);
        console.log("üìÑ Extracted HTML length:", cleanHTML.length);

        if (cleanHTML.length < 200) {
          throw new Error("Insufficient content extracted from webpage");
        }

        recipeData = await parseRecipeWithAI(cleanHTML, url);
        parsingMethod = "AI";
        console.log("‚úÖ AI parsing completed:", recipeData.name);
      } catch (error) {
        console.error("‚ùå AI parsing failed:", error.message);
        return res.status(422).json({
          error: "Recipe Extraction Failed",
          message:
            "Could not extract recipe content from this webpage. The page might not contain a recipe, or the content is not accessible.",
          details: error.message,
          suggestion:
            "Try a different recipe URL or manually input the recipe.",
          code: "EXTRACTION_FAILED",
        });
      }
    }

    // Step 4: Validate the parsed data
    const validationErrors = validateRecipeData(recipeData);
    if (validationErrors.length > 0) {
      console.error("‚ùå Validation failed:", validationErrors.join(", "));
      return res.status(422).json({
        error: "Incomplete Recipe Data",
        message: "The parsed recipe data is missing required fields.",
        details: validationErrors.join(", "),
        code: "VALIDATION_ERROR",
      });
    }

    // Step 5: Process and structure the data
    //
    const processedData = sanitizeRecipeData({
      name: recipeData.name?.trim() || "",
      image: recipeData.image || "",
      description: recipeData.description || `A recipe for ${recipeData.name}`,
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: recipeData.category,
      cuisine: recipeData.cuisine,
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url,
      parsingMethod: parsingMethod,
    });
    // Step 6: Enhance the data with another AI call
    console.log("‚ú® Enhancing recipe with AI...");
    const enhancedData = await enhanceRecipeWithAI(processedData);

    // Step 7: Save the final recipe to the database
    console.log("üíæ Saving recipe to the database...");
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing recipe:", error);
    res.status(500).json({
      error: "Server Error",
      message: "An unexpected error occurred while processing the recipe.",
      details: error.message,
    });
  }
});

// Add a new route for manual recipe input
recipeRouter.post("/manual", async (req, res) => {
  try {
    const { recipeText, url } = req.body;

    if (!recipeText) {
      return res.status(400).json({ error: "Recipe text is required" });
    }

    console.log("üìù Processing manually provided recipe text...");

    // Use AI to parse the manually provided text
    const recipeData = await parseRecipeWithAI(
      recipeText,
      url || "manual-input",
    );

    // Process and save as normal
    const processedData = {
      name: recipeData.name.trim(),
      image: recipeData.image || "",
      description: recipeData.description || "Manually added recipe",
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: Array.isArray(recipeData.category)
        ? recipeData.category
        : [recipeData.category].filter(Boolean),
      cuisine: Array.isArray(recipeData.cuisine)
        ? recipeData.cuisine
        : [recipeData.cuisine].filter(Boolean),
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url || "manual-input",
      parsingMethod: "Manual + AI",
    };

    // Enhance and save
    const enhancedData = await enhanceRecipeWithAI(processedData);
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Manual recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing manual recipe:", error);
    res.status(500).json({
      error: "Failed to process manual recipe: " + error.message,
    });
  }
});

recipeRouter.put("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const updatedRecipe = await Recipe.findByIdAndUpdate(id, updates, {
      new: true,
    });

    if (!updatedRecipe) {
      return res.status(404).json({ error: "Recipe not found" });
    }

    res.json(updatedRecipe);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.get("/:id", async (req, res) => {
  const id = req.params.id;
  const recipe = await Recipe.findById(id);
  res.json(recipe);
});

export { recipeRouter };
```

### üìÑ `index.js`

**Path:** `index.js`  
**Size:** 131 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { app } from "./app.js";
import { PORT } from "./utils/config.js";
app.listen(PORT, () => console.log(`connected on the ${PORT}`));
```

### üìÑ `notes.js`

**Path:** `models/notes.js`  
**Size:** 490 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import mongoose from "mongoose";

const noteSchema = new mongoose.Schema({
  recipeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Recipe",
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    enum: ["chat", "note"],
    required: true,
  },
  isFromAI: {
    type: Boolean,
    default: false,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

export const Note = mongoose.model("Note", noteSchema);
```

### üìÑ `recipe.js`

**Path:** `models/recipe.js`  
**Size:** 813 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import mongoose from "mongoose";

const recipeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  image: {
    type: String, // Changed to handle URL string or object.url
  },
  description: {
    type: String,
  },
  cookTime: {
    type: String,
  },
  prepTime: {
    type: String,
  },
  totalTime: {
    type: String,
  },
  category: {
    type: [String], // Changed to array of strings
  },
  cuisine: {
    type: [String], // Changed to array of strings
  },
  ingredients: {
    type: [String],
    required: true,
  },
  instructions: {
    type: [String],
    required: true,
  },
  yield: {
    type: String,
  },
  sourceUrl: {
    type: String,
  },
  dateAdded: {
    type: Date,
    default: Date.now,
  },
});

export const Recipe = mongoose.model("Recipe", recipeSchema);
```

### üìÑ `package.json`

**Path:** `package.json`  
**Size:** 534 B  
**Language:** json (high confidence)  
**Category:** Data/Config

```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "license": "ISC",
  "author": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node --watch index.js ",
    "start": "node index.js"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "mongodb": "^6.19.0",
    "mongoose": "^8.18.0",
    "tinyduration": "^3.4.1"
  }
}
```

### üìÑ `ai-recipe-parser.js`

**Path:** `utils/ai-recipe-parser.js`  
**Size:** 6.8 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

````javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const parseRecipeWithAI = async (htmlContent, url) => {
  console.log("ü§ñ Parsing recipe with AI from HTML content...");
  console.log("üìè Content length:", htmlContent.length);

  if (htmlContent.length < 100) {
    throw new Error("Insufficient content to parse recipe");
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048,
      },
    });

    const contentForAI =
      htmlContent.length > 12000
        ? htmlContent.substring(0, 12000) + "...[content continues]"
        : htmlContent;

    const prompt = `
Analyze this webpage content and extract recipe information. URL: ${url}

Content:
${contentForAI}

Extract recipe details and return a JSON object with this structure:
{
  "name": "Recipe Title",
  "description": "Brief description",
  "image": "image URL as string or empty string",
  "cookTime": "cooking time",
  "prepTime": "prep time", 
  "totalTime": "total time",
  "category": ["category1", "category2"],
  "cuisine": ["cuisine1"],
  "ingredients": ["ingredient 1 with quantity", "ingredient 2"],
  "instructions": ["step 1", "step 2", "step 3"],
  "yield": "servings"
}

IMPORTANT:
- For image field, return ONLY the URL string, not an object
- Extract the actual recipe name from the content
- Find ALL ingredients listed (even if formatting is unclear)
- Extract ALL cooking steps/instructions
- Return valid JSON only, no markdown formatting

JSON:`;

    console.log("üì§ Sending to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    console.log("üì• Raw response length:", text.length);
    console.log("üì• Response preview:", text.substring(0, 150) + "...");

    text = text
      .replace(/```json\s*/g, "")
      .replace(/```\s*/g, "")
      .replace(/`/g, "")
      .trim();

    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      text = jsonMatch[0];
    }

    let aiRecipe;
    try {
      aiRecipe = JSON.parse(text);
    } catch (parseError) {
      console.error("‚ùå JSON parse error:", parseError);
      console.log("üîç Cleaned text:", text);
      throw new Error("AI returned invalid JSON format");
    }

    // Helper function to extract image URL
    const extractImageUrl = (imageData) => {
      if (!imageData) return "";
      if (typeof imageData === "string") return imageData;
      if (Array.isArray(imageData)) {
        const firstImage = imageData[0];
        if (typeof firstImage === "string") return firstImage;
        if (firstImage && firstImage.url) return firstImage.url;
        return "";
      }
      if (imageData.url) return imageData.url;
      return "";
    };

    // Validate and enhance the recipe data
    const validatedRecipe = {
      name: aiRecipe.name?.trim() || `Recipe from ${new URL(url).hostname}`,
      description: aiRecipe.description?.trim() || "A delicious recipe",
      image: extractImageUrl(aiRecipe.image), // Fix: Properly extract image URL
      cookTime: aiRecipe.cookTime || "",
      prepTime: aiRecipe.prepTime || "",
      totalTime: aiRecipe.totalTime || "",
      category: Array.isArray(aiRecipe.category)
        ? aiRecipe.category
        : aiRecipe.category
          ? [aiRecipe.category]
          : ["Main Course"],
      cuisine: Array.isArray(aiRecipe.cuisine)
        ? aiRecipe.cuisine
        : aiRecipe.cuisine
          ? [aiRecipe.cuisine]
          : ["Indian"],
      ingredients:
        Array.isArray(aiRecipe.ingredients) && aiRecipe.ingredients.length > 0
          ? aiRecipe.ingredients
          : [
              "Ingredients not clearly specified - please check the original recipe",
            ],
      instructions:
        Array.isArray(aiRecipe.instructions) && aiRecipe.instructions.length > 0
          ? aiRecipe.instructions
          : [
              "Instructions not clearly specified - please check the original recipe",
            ],
      yield: aiRecipe.yield || "4 servings",
    };

    console.log("‚úÖ Validated recipe:", {
      name: validatedRecipe.name,
      image: validatedRecipe.image,
      ingredientsCount: validatedRecipe.ingredients.length,
      instructionsCount: validatedRecipe.instructions.length,
    });

    return validatedRecipe;
  } catch (error) {
    console.error("‚ùå Error in AI parsing:", error);

    const hostname = new URL(url).hostname;
    return {
      name: `Recipe from ${hostname}`,
      description: `Recipe from ${url} - content could not be fully extracted`,
      image: "", // Fix: Always return string
      cookTime: "",
      prepTime: "",
      totalTime: "",
      category: ["Main Course"],
      cuisine: hostname.includes("indian") ? ["Indian"] : ["Unknown"],
      ingredients: [
        "Ingredients not available - please visit the original recipe",
        `Original URL: ${url}`,
      ],
      instructions: [
        "Instructions not available - please visit the original recipe",
        `Please visit: ${url}`,
      ],
      yield: "4 servings",
    };
  }
};
const enhanceRecipeWithAI = async (recipeData) => {
  console.log("üéØ Enhancing recipe:", recipeData.name);

  // Skip enhancement if the basic data is missing or is a fallback
  if (
    !recipeData.name ||
    recipeData.name.trim() === "" ||
    recipeData.ingredients[0]?.includes("not available") ||
    recipeData.instructions[0]?.includes("not available")
  ) {
    console.log("‚ö†Ô∏è Skipping enhancement - insufficient data");
    return recipeData;
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.1,
      },
    });

    const prompt = `
Improve categorization for this recipe:

Name: ${recipeData.name}
Current categories: ${JSON.stringify(recipeData.category)}
Current cuisines: ${JSON.stringify(recipeData.cuisine)}
First 3 ingredients: ${recipeData.ingredients?.slice(0, 3).join(", ")}

Return only JSON:
{
  "category": ["improved categories"],
  "cuisine": ["improved cuisines"]
}

Categories: Appetizer, Main Course, Dessert, Breakfast, Snack, Side Dish, Soup, Salad
Cuisines: Indian, Italian, Mexican, Asian, American, Mediterranean, Chinese, etc.`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    text = text
      .replace(/```json/g, "")
      .replace(/```/g, "")
      .trim();

    const enhanced = JSON.parse(text);

    return {
      ...recipeData,
      category: enhanced.category || recipeData.category,
      cuisine: enhanced.cuisine || recipeData.cuisine,
    };
  } catch (error) {
    console.error("‚ùå Enhancement failed:", error);
    return recipeData;
  }
};

export { parseRecipeWithAI, enhanceRecipeWithAI };
````

### üìÑ `config.js`

**Path:** `utils/config.js`  
**Size:** 299 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import dotenv from "dotenv";

dotenv.config(); // must be at the top-level before accessing process.env

const PORT = process.env.PORT || 3001;
const url = process.env.MONGODB_URI;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY; // Fixed naming consistency

export { url, PORT, GEMINI_API_KEY };
```

### üìÑ `debug-recpe.js`

**Path:** `utils/debug-recpe.js`  
**Size:** 1.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { findLDJSON, extractRecipeHTML } from "./fetch.js";
import { parseRecipeWithAI } from "./ai-recipe-parser.js";
import dotenv from "dotenv";

dotenv.config();

async function debugRecipe(url) {
  console.log("üß™ Debugging recipe parsing for:", url);

  try {
    const { jsonLd, html, $ } = await findLDJSON(url);

    if (jsonLd) {
      console.log("‚úÖ JSON-LD found:", Object.keys(jsonLd));
    } else {
      console.log("‚ùå No JSON-LD found");

      const cleanHTML = extractRecipeHTML($);
      console.log("üìÑ HTML length:", cleanHTML.length);
      console.log("üìÑ First 200 chars:", cleanHTML.substring(0, 200));

      const aiResult = await parseRecipeWithAI(cleanHTML, url);
      console.log("ü§ñ AI Result:", {
        name: aiResult.name,
        nameLength: aiResult.name?.length,
        hasIngredients: aiResult.ingredients?.length > 0,
        hasInstructions: aiResult.instructions?.length > 0,
      });
    }
  } catch (error) {
    console.error("‚ùå Debug failed:", error);
  }
}

// Test with a recipe URL
debugRecipe("https://www.recipetineats.com/chicken-breast-recipe/");
```

### üìÑ `fetch.js`

**Path:** `utils/fetch.js`  
**Size:** 8.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import * as cheerio from "cheerio";
import * as duration from "tinyduration";

const parseInstructions = (instructions) => {
  let result = [];
  for (let instruction of instructions) {
    if (typeof instruction === "string") result.push(instruction);
    else {
      if (instruction["@type"] === "HowToStep") result.push(instruction.text);
    }
  }
  return result;
};

const findLDJSON = async (u) => {
  console.log("üåê Fetching URL with proper headers:", u);

  try {
    // Add headers to mimic a real browser
    const headers = {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      Accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
      "Accept-Language": "en-US,en;q=0.5",
      "Accept-Encoding": "gzip, deflate, br",
      Connection: "keep-alive",
      "Upgrade-Insecure-Requests": "1",
      "Sec-Fetch-Dest": "document",
      "Sec-Fetch-Mode": "navigate",
      "Sec-Fetch-Site": "none",
      "Cache-Control": "max-age=0",
    };

    let req = await fetch(u, {
      headers,
      method: "GET",
    });

    if (!req.ok) {
      throw new Error(`HTTP ${req.status}: ${req.statusText}`);
    }

    let html = await req.text();

    // Check if we got blocked by firewall
    if (
      html.includes("Sucuri Website Firewall") ||
      html.includes("Access Denied") ||
      html.includes("blocked") ||
      html.length < 1000
    ) {
      console.log("üö´ Request blocked by firewall or bot detection");
      return {
        html: null,
        $: null,
        blocked: true,
        error:
          "Website blocked the request. This site uses anti-bot protection.",
      };
    }

    let $ = cheerio.load(html);
    let jdjson = $("script[type='application/ld+json']");

    if (jdjson.length === 0) {
      console.log("üìÑ No JSON-LD found, will use HTML parsing");
      return { html, $ };
    }

    let content = JSON.parse(jdjson[0].children[0].data);

    if (Array.isArray(content)) return { jsonLd: content[0], html, $ };
    else {
      if (content["@graph"] && Array.isArray(content["@graph"])) {
        for (let t of content["@graph"]) {
          if (t["@type"] === "Recipe") return { jsonLd: t, html, $ };
        }
      }
    }
    return { html, $ };
  } catch (error) {
    console.error("‚ùå Fetch error:", error.message);
    return {
      html: null,
      $: null,
      blocked: true,
      error: `Failed to fetch: ${error.message}`,
    };
  }
};

const durationToStr = (d) => {
  if (!d) return "";
  let parsed = duration.parse(d);
  let result = [];
  if (parsed.hours) {
    result.push(`${parsed.hours} hours`);
  }
  if (parsed.minutes) {
    result.push(`${parsed.minutes} minutes`);
  }
  if (parsed.seconds) {
    result.push(`${parsed.seconds} seconds`);
  }

  let formatter = new Intl.ListFormat("en", {
    style: "long",
    type: "conjunction",
  });
  return formatter.format(result);
};

const findRecipe = async (jdjson) => {
  if (jdjson["@type"].indexOf("Recipe") === -1) return;

  let result = {};
  result.name = jdjson["name"];

  // Fix: Handle ImageObject properly
  if (jdjson["image"]) {
    if (typeof jdjson["image"] === "string") {
      result.image = jdjson["image"];
    } else if (Array.isArray(jdjson["image"])) {
      // Handle array of images - take the first one
      const firstImage = jdjson["image"][0];
      if (typeof firstImage === "string") {
        result.image = firstImage;
      } else if (firstImage && firstImage.url) {
        result.image = firstImage.url;
      } else {
        result.image = "";
      }
    } else if (jdjson["image"].url) {
      // Handle ImageObject
      result.image = jdjson["image"].url;
    } else {
      result.image = "";
    }
  } else {
    result.image = "";
  }

  result.description = jdjson["description"];
  result.cookTime = durationToStr(jdjson["cookTime"]);
  result.prepTime = durationToStr(jdjson["prepTime"]);
  result.totalTime = durationToStr(jdjson["totalTime"]);
  result.category = jdjson["recipeCategory"] ?? "";
  result.cuisine = jdjson["recipeCuisine"] ?? "";
  result.ingredients = jdjson["recipeIngredient"];
  result.instructions = parseInstructions(jdjson["recipeInstructions"]);

  // Fix: Handle recipeYield properly
  if (jdjson["recipeYield"]) {
    if (Array.isArray(jdjson["recipeYield"])) {
      result.yield = jdjson["recipeYield"][0];
    } else {
      result.yield = jdjson["recipeYield"];
    }
  } else {
    result.yield = "";
  }

  return result;
};

const extractRecipeHTML = ($) => {
  if (!$) {
    return "No content available";
  }

  console.log("üîç Extracting recipe content from HTML...");

  // Remove unwanted elements first
  $(
    "script, style, nav, header, footer, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation",
  ).remove();

  let recipeContent = "";
  let contentFound = false;

  // Try multiple strategies to find recipe content
  const strategies = [
    // Strategy 1: Look for recipe-specific selectors
    () => {
      const selectors = [
        '[itemtype*="Recipe"]',
        ".recipe-card",
        ".recipe-content",
        ".recipe-post",
        ".recipe-container",
        ".recipe",
        ".entry-recipe",
        ".post-recipe",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìã Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 2: Look for main content areas
    () => {
      const selectors = [
        "main",
        "article",
        ".entry-content",
        ".post-content",
        ".content",
        "#content",
        ".main-content",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìÑ Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 3: Look for specific content patterns
    () => {
      // Look for elements containing recipe keywords
      const recipeKeywords = [
        "ingredients",
        "instructions",
        "directions",
        "recipe",
        "cook",
        "prep",
      ];
      let bestElement = null;
      let maxScore = 0;

      $("div, section, article").each((i, elem) => {
        const $elem = $(elem);
        const text = $elem.text().toLowerCase();
        let score = 0;

        recipeKeywords.forEach((keyword) => {
          if (text.includes(keyword)) score++;
        });

        if (score > maxScore && $elem.text().length > 200) {
          maxScore = score;
          bestElement = $elem;
        }
      });

      if (bestElement) {
        console.log(
          `üéØ Found content with keyword matching (score: ${maxScore})`,
        );
        return bestElement.html();
      }
      return null;
    },

    // Strategy 4: Fallback to body content
    () => {
      console.log("üì¶ Using full body content as fallback");
      return $("body").html();
    },
  ];

  // Try each strategy until we find content
  for (const strategy of strategies) {
    const content = strategy();
    if (content && content.length > 100) {
      // Minimum content length
      recipeContent = content;
      contentFound = true;
      break;
    }
  }

  if (!contentFound) {
    console.log("‚ùå No substantial content found");
    return "No recipe content found";
  }

  // Clean up the extracted content
  const cleanedContent = cheerio.load(recipeContent);

  // Remove more unwanted elements from the extracted content
  cleanedContent(
    "script, style, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation, .popup, .modal",
  ).remove();

  // Get text content and clean it up
  let textContent = cleanedContent.text();

  // Clean up whitespace and formatting
  textContent = textContent
    .replace(/\s+/g, " ") // Replace multiple whitespace with single space
    .replace(/\n\s*\n/g, "\n") // Remove empty lines
    .trim();

  console.log(`üìè Extracted content length: ${textContent.length} characters`);

  return textContent;
};

export { findLDJSON, findRecipe, extractRecipeHTML };
```

### üìÑ `gemini.js`

**Path:** `utils/gemini.js`  
**Size:** 3.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

````javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const enhanceRecipeWithAI = async (recipeData) => {
  console.log("ü§ñ Starting AI enhancement for recipe:", recipeData.name);
  console.log("üìä Original data:", {
    category: recipeData.category,
    cuisine: recipeData.cuisine,
    ingredients: recipeData.ingredients?.slice(0, 3), // Just first 3 for logging
  });

  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    const prompt = `
Please analyze this recipe data and provide better categorization and cataloguing. 
Return ONLY a valid JSON object (no markdown, no code blocks, no additional text).

Expected format:
{
  "category": ["array", "of", "categories"],
  "cuisine": ["array", "of", "cuisines"],
  "name": "improved recipe name if needed",
  "description": "improved description if needed"
}

Recipe data to analyze:
Name: ${recipeData.name}
Description: ${recipeData.description}
Ingredients: ${recipeData.ingredients?.join(", ")}
Instructions: ${recipeData.instructions?.slice(0, 3).join(". ")}
Original Category: ${recipeData.category}
Original Cuisine: ${recipeData.cuisine}

Focus on:
- Better food categories (e.g., "Dessert", "Main Course", "Appetizer", "Breakfast", "Snack")
- More specific cuisine types (e.g., "Italian", "Mexican", "Asian", "Mediterranean")
- Keep the same name and description unless they need minor improvements

IMPORTANT: Return ONLY the JSON object, no other text or formatting.
`;

    console.log("üì§ Sending prompt to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    console.log("üì• Raw AI response:", text);

    // Clean the response to extract JSON
    text = text.trim();

    // Remove markdown code blocks if present
    if (text.startsWith("```json")) {
      text = text.replace(/^```json\s*/, "").replace(/\s*```$/, "");
    } else if (text.startsWith("```")) {
      text = text.replace(/^```\s*/, "").replace(/\s*```$/, "");
    }

    // Remove any remaining backticks
    text = text.replace(/`/g, "");

    console.log("üßπ Cleaned response:", text);

    // Parse the AI response
    const aiEnhancements = JSON.parse(text.trim());
    console.log("‚úÖ Parsed AI enhancements:", aiEnhancements);

    const enhancedData = {
      ...recipeData,
      category: aiEnhancements.category || recipeData.category,
      cuisine: aiEnhancements.cuisine || recipeData.cuisine,
      name: aiEnhancements.name || recipeData.name,
      description: aiEnhancements.description || recipeData.description,
    };

    console.log("üéØ Final enhanced data:", {
      category: enhancedData.category,
      cuisine: enhancedData.cuisine,
      nameChanged: enhancedData.name !== recipeData.name,
      descriptionChanged: enhancedData.description !== recipeData.description,
    });

    return enhancedData;
  } catch (error) {
    console.error("‚ùå Error enhancing recipe with AI:", error);
    console.log("üîÑ Falling back to original data");
    // Return original data if AI processing fails
    return recipeData;
  }
};

export { enhanceRecipeWithAI };
````

### üìÑ `recipe-chat-ai.js`

**Path:** `utils/recipe-chat-ai.js`  
**Size:** 2.9 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { GoogleGenerativeAI } from "@google/generative-ai";
import "dotenv/config";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const chatWithRecipeAI = async (recipe, userMessage) => {
  console.log("ü§ñ Processing chat about recipe:", recipe.name);

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1024,
        responseMimeType: "application/json",
        responseSchema: {
          type: "object",
          properties: {
            response: {
              type: "string",
              description: "The main response to the user's question",
            },
            suggestions: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  ingredient: { type: "string" },
                  substitutes: {
                    type: "array",
                    items: { type: "string" },
                  },
                  notes: { type: "string" },
                },
              },
            },
            tips: {
              type: "array",
              items: { type: "string" },
            },
          },
        },
      },
    });

    const recipeContext = `
Recipe: ${recipe.name}
Description: ${recipe.description}
Prep Time: ${recipe.prepTime}
Cook Time: ${recipe.cookTime}
Total Time: ${recipe.totalTime}
Serves: ${recipe.yield}
Category: ${recipe.category?.join(", ")}
Cuisine: ${recipe.cuisine?.join(", ")}

Ingredients:
${recipe.ingredients?.map((ing, i) => `${i + 1}. ${ing}`).join("\n")}

Instructions:
${recipe.instructions?.map((inst, i) => `${i + 1}. ${inst}`).join("\n")}
`;

    const prompt = `
You are a helpful cooking assistant. A user is asking about this specific recipe:

${recipeContext}

User question: ${userMessage}

Please provide a structured response with:
1. A main response answering their question
2. If they're asking about substitutions, provide an array of ingredient substitution suggestions
3. Any relevant cooking tips

Format your response as JSON with the specified schema. Be helpful, friendly, and concise.
`;

    const result = await model.generateContent(prompt);
    const response = await result.response;

    try {
      const jsonResponse = JSON.parse(response.text());

      // IMPORTANT: Return only the string response for your current backend
      // Your backend expects a string, not an object
      return jsonResponse.response || "I couldn't generate a proper response.";
    } catch (parseError) {
      // Fallback to plain text if JSON parsing fails
      console.warn("Failed to parse JSON response, falling back to plain text");
      return response.text().trim();
    }
  } catch (error) {
    console.error("‚ùå Error in recipe chat AI:", error);
    return "I'm sorry, I couldn't process your question right now. Please try again later.";
  }
};

export { chatWithRecipeAI };
```

### üìÑ `test-ai-fallback.js`

**Path:** `utils/test-ai-fallback.js`  
**Size:** 1.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { findLDJSON, findRecipe, extractRecipeHTML } from "./fetch.js";
import { parseRecipeWithAI } from "./ai-recipe-parser.js";
import dotenv from "dotenv";

dotenv.config();

// Test URLs - one with JSON-LD and one without
const testUrls = [
  "https://www.allrecipes.com/recipe/10275/classic-peanut-butter-cookies/", // Has JSON-LD
  "https://www.food.com/recipe/simple-chocolate-chip-cookies-16589", // May not have JSON-LD
];

async function testBothMethods() {
  for (const url of testUrls) {
    console.log(`\nüß™ Testing: ${url}`);

    try {
      // Try JSON-LD first
      const { jsonLd, html, $ } = await findLDJSON(url);

      if (jsonLd) {
        console.log("‚úÖ JSON-LD found");
        const recipe = await findRecipe(jsonLd);
        if (recipe) {
          console.log("‚úÖ JSON-LD parsing successful:", recipe.name);
        }
      } else {
        console.log("‚ö†Ô∏è No JSON-LD found, trying AI...");
        const cleanHTML = extractRecipeHTML($);
        const aiRecipe = await parseRecipeWithAI(cleanHTML, url);
        console.log("‚úÖ AI parsing successful:", aiRecipe.name);
      }
    } catch (error) {
      console.error("‚ùå Error:", error.message);
    }
  }
}

testBothMethods();
```

### üìÑ `test.js`

**Path:** `utils/test.js`  
**Size:** 1.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend

```javascript
import { enhanceRecipeWithAI } from "./gemini.js";
import dotenv from "dotenv";

dotenv.config();

const testRecipe = {
  name: "Chocolate Chip Cookies",
  description: "Classic homemade cookies",
  category: ["Cookies"],
  cuisine: ["American"],
  ingredients: [
    "2 cups all-purpose flour",
    "1 cup butter",
    "1 cup brown sugar",
    "2 eggs",
    "1 tsp vanilla",
    "1 cup chocolate chips",
  ],
  instructions: [
    "Preheat oven to 375¬∞F",
    "Mix butter and sugar",
    "Add eggs and vanilla",
    "Mix in flour",
    "Fold in chocolate chips",
    "Bake for 12 minutes",
  ],
};

async function testAI() {
  console.log("üß™ Testing AI enhancement...");
  console.log("üìã Original recipe:", testRecipe);

  try {
    const enhanced = await enhanceRecipeWithAI(testRecipe);
    console.log("‚úÖ Enhanced recipe:", enhanced);

    // Check if categories changed
    const categoriesChanged =
      JSON.stringify(enhanced.category) !== JSON.stringify(testRecipe.category);
    const cuisineChanged =
      JSON.stringify(enhanced.cuisine) !== JSON.stringify(testRecipe.cuisine);

    console.log("üìä Changes detected:");
    console.log(`  Categories changed: ${categoriesChanged}`);
    console.log(`  Cuisine changed: ${cuisineChanged}`);

    if (categoriesChanged || cuisineChanged) {
      console.log("üéâ AI is working! Data was enhanced.");
    } else {
      console.log("‚ö†Ô∏è No changes detected. Check AI prompt or API connection.");
    }
  } catch (error) {
    console.error("‚ùå Test failed:", error);
  }
}

testAI();
```

---
