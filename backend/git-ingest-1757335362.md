# üöÄ Project Analysis Report

Directory structure for: backend

## üéØ LLM-Optimized Codebase Analysis

This document provides a comprehensive, structured analysis of the codebase optimized for 
Large Language Model (LLM) processing. The content is organized with semantic markup, 
proper syntax highlighting, and hierarchical structure for enhanced AI comprehension.

## üìë Table of Contents

- [üìä Project Overview](#-project-overview)
- [üìà Statistics](#-statistics)
- [üèóÔ∏è Directory Structure](#Ô∏è-directory-structure)
- [üìÅ Files by Category](#-files-by-category)
  - [üåê Web Frontend](#1f310-web-frontend)
  - [‚öôÔ∏è Data/Config](#2699-data-config)
- [üìã Complete File Listing](#-complete-file-listing)

## üìä Project Overview

**Project:** `backend`  
**Path:** `/home/chaitanya/projects/whisk/backend`  
**Generated:** 2025-09-08T12:42:42.183Z  
**Total Files:** 13  
**Total Size:** 38.8 KB  

### üéØ Quick Summary

This document contains a comprehensive analysis of the **backend** project, 
including its complete directory structure and the full content of all text files. 
The content is organized in a hierarchical, LLM-friendly format with proper syntax 
highlighting and metadata for optimal AI processing.

## üìà Statistics

### üìä File Type Distribution

| Category | Files | Percentage |
| --- | --- | --- |
| Web Frontend | 12 | 92.3% |
| Data/Config | 1 | 7.7% |

### üíª Programming Languages

| Language | Files | Primary Category |
| --- | --- | --- |
| javascript | 12 | Web Frontend |
| json | 1 | Data/Config |

### üìè Size Analysis

- **Total Project Size:** 38.8 KB
- **Average File Size:** 3 KB
- **Text Files:** 13 (100.0%)

## üèóÔ∏è Directory Structure

```
‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îú‚îÄ‚îÄ chat.js
‚îÇ   ‚îî‚îÄ‚îÄ routes.js
‚îú‚îÄ‚îÄ models
‚îÇ   ‚îú‚îÄ‚îÄ notes.js
‚îÇ   ‚îî‚îÄ‚îÄ recipe.js
‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îú‚îÄ‚îÄ ai-recipe-parser.js
‚îÇ   ‚îú‚îÄ‚îÄ auth.js
‚îÇ   ‚îú‚îÄ‚îÄ config.js
‚îÇ   ‚îú‚îÄ‚îÄ fetch.js
‚îÇ   ‚îú‚îÄ‚îÄ gemini.js
‚îÇ   ‚îî‚îÄ‚îÄ recipe-chat-ai.js
‚îú‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ package.json
```

## üìÅ Files by Category

### üåê Web Frontend

**Languages:** javascript  
**File Count:** 12

### ‚öôÔ∏è Data/Config

**Languages:** json  
**File Count:** 1
## üìã Complete File Listing

The following section contains the complete content of all text files in the project, 
organized with proper syntax highlighting and metadata for optimal LLM processing.

### üìÑ `app.js`

**Path:** `app.js`  
**Size:** 1.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { url } from "./utils/config.js";
import { recipeRouter } from "./controllers/routes.js";
import { chatRouter } from "./controllers/chat.js";
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import "dotenv/config";
const app = express();

console.log("Connecting to the db");
const connectDB = async () => {
  try {
    await mongoose.connect(url);
    console.log("Connected to MongoDB");
  } catch (error) {
    console.error("Error connecting to DB:", error.message);
    process.exit(1); // Exit if database connection fails
  }
};

connectDB();

// Middleware
app.use(cors());
app.use(express.json());

// API routes - Fixed routing conflict
app.use("/api/recipes", recipeRouter);
app.use("/api/chat", chatRouter); // Changed to different path

// Error handler middleware
app.use((error, request, response, next) => {
  console.error(error.message);

  if (error.name === "CastError") {
    return response.status(400).send({ error: "Malformatted ID" });
  } else if (error.name === "ValidationError") {
    return response.status(400).json({ error: error.message });
  }

  next(error);
});

export { app };
```

### üìÑ `chat.js`

**Path:** `controllers/chat.js`  
**Size:** 3.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { Router } from "express";
import { Note } from "../models/notes.js"; // Fixed import path
import { Recipe } from "../models/recipe.js";
import { chatWithRecipeAI } from "../utils/recipe-chat-ai.js";

const chatRouter = Router();

// Get all notes/chats for a recipe - Updated route
chatRouter.get("/recipes/:recipeId/notes", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const notes = await Note.find({ recipeId }).sort({ timestamp: 1 });
    res.json(notes);
  } catch (error) {
    console.error("Error fetching notes:", error);
    res.status(500).json({ error: error.message });
  }
});

// Save a note - Updated route
chatRouter.post("/recipes/:recipeId/notes", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const { content, type } = req.body;

    if (!content || !type) {
      return res.status(400).json({ error: "Content and type are required" });
    }

    const note = new Note({
      recipeId,
      content,
      type,
      isFromAI: false,
    });

    const savedNote = await note.save();
    res.status(201).json(savedNote);
  } catch (error) {
    console.error("Error saving note:", error);
    res.status(500).json({ error: error.message });
  }
});
chatRouter.delete("/recipes/:recipeId/chat", async (req, res) => {
  try {
    const { recipeId } = req.params;

    // Delete only chat messages for this recipe (keep notes)
    const result = await Note.deleteMany({
      recipeId,
      type: "chat",
    });

    res.json({
      message: `Cleared ${result.deletedCount} chat messages`,
      deletedCount: result.deletedCount,
    });
  } catch (error) {
    console.error("Error clearing chat history:", error);
    res.status(500).json({ error: error.message });
  }
});
// Chat with AI about a recipe - Updated route
chatRouter.post("/recipes/:recipeId/chat", async (req, res) => {
  try {
    const { recipeId } = req.params;
    const { message } = req.body;

    if (!message) {
      return res.status(400).json({ error: "Message is required" });
    }

    // Get the recipe data
    const recipe = await Recipe.findById(recipeId);
    if (!recipe) {
      return res.status(404).json({ error: "Recipe not found" });
    }

    // Save user message
    const userNote = new Note({
      recipeId,
      content: message,
      type: "chat",
      isFromAI: false,
    });
    await userNote.save();

    // Get AI response
    const aiResponse = await chatWithRecipeAI(recipe, message);

    // FIX: Ensure we save a string, not an object
    let aiContent;
    if (typeof aiResponse === "object") {
      // If it's an object, stringify it or extract the main response
      aiContent = aiResponse.response || JSON.stringify(aiResponse);
    } else {
      aiContent = aiResponse;
    }

    // Save AI response
    const aiNote = new Note({
      recipeId,
      content: aiContent, // Now guaranteed to be a string
      type: "chat",
      isFromAI: true,
    });
    await aiNote.save();

    res.json({
      userMessage: userNote,
      aiResponse: aiNote,
    });
  } catch (error) {
    console.error("Error in chat:", error);
    res.status(500).json({ error: error.message });
  }
});

// Delete a note
chatRouter.delete("/notes/:noteId", async (req, res) => {
  try {
    const { noteId } = req.params;
    await Note.findByIdAndDelete(noteId);
    res.status(204).end();
  } catch (error) {
    console.error("Error deleting note:", error);
    res.status(500).json({ error: error.message });
  }
});

export { chatRouter };
```

### üìÑ `routes.js`

**Path:** `controllers/routes.js`  
**Size:** 9.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { response, Router } from "express";
import { Recipe } from "../models/recipe.js";
import { findLDJSON, findRecipe, extractRecipeHTML } from "../utils/fetch.js";
import {
  parseRecipeWithAI,
  enhanceRecipeWithAI,
} from "../utils/ai-recipe-parser.js";

const recipeRouter = Router();
const sanitizeRecipeData = (data) => {
  return {
    ...data,
    image: typeof data.image === "string" ? data.image : data.image?.url || "",
    name: typeof data.name === "string" ? data.name.trim() : "",
    description:
      typeof data.description === "string" ? data.description.trim() : "",
    cookTime: typeof data.cookTime === "string" ? data.cookTime : "",
    prepTime: typeof data.prepTime === "string" ? data.prepTime : "",
    totalTime: typeof data.totalTime === "string" ? data.totalTime : "",
    yield:
      typeof data.yield === "string"
        ? data.yield
        : Array.isArray(data.yield)
          ? data.yield[0]
          : "",
    category: Array.isArray(data.category)
      ? data.category
      : data.category
        ? [data.category]
        : [],
    cuisine: Array.isArray(data.cuisine)
      ? data.cuisine
      : data.cuisine
        ? [data.cuisine]
        : [],
    ingredients: Array.isArray(data.ingredients) ? data.ingredients : [],
    instructions: Array.isArray(data.instructions) ? data.instructions : [],
  };
};
// Validation function
const validateRecipeData = (data) => {
  const errors = [];

  if (!data.name || data.name.trim() === "") {
    errors.push("Recipe name is required");
  }

  // More lenient validation - allow placeholder content
  if (!Array.isArray(data.ingredients) || data.ingredients.length === 0) {
    errors.push("Recipe must have ingredients information");
  }

  if (!Array.isArray(data.instructions) || data.instructions.length === 0) {
    errors.push("Recipe must have instructions information");
  }

  return errors;
};

recipeRouter.get("/", async (req, res) => {
  try {
    const recipes = await Recipe.find({});
    res.json(recipes);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.delete("/:id", async (request, response) => {
  try {
    const { id } = request.params;

    const deletedRecipe = await Recipe.findByIdAndDelete(id);

    if (!deletedRecipe) {
      return response.status(404).json({ error: "Recipe not found" });
    }

    response.status(204).end();
  } catch (error) {
    console.error("Error deleting recipe:", error);
    response.status(500).json({ error: error.message });
  }
});

recipeRouter.post("/parse", async (req, res) => {
  try {
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: "URL is required" });
    }

    console.log("üîç Starting recipe parsing for:", url);

    // Step 1: Try to get data from URL
    const fetchResult = await findLDJSON(url);

    // Handle blocked requests
    if (fetchResult.blocked) {
      console.log("üö´ Website blocked the request");

      // Provide manual input option
      return res.status(403).json({
        error: "Website Access Blocked",
        message: fetchResult.error,
        suggestion:
          "This website uses anti-bot protection. You can manually copy and paste the recipe content, or try a different recipe URL.",
        blockedUrl: url,
        code: "BLOCKED_BY_FIREWALL",
      });
    }

    const { jsonLd, html, $ } = fetchResult;
    let recipeData = null;
    let parsingMethod = "";

    // Step 2: Try JSON-LD first
    if (jsonLd) {
      console.log("üìã Found JSON-LD data, attempting to parse...");
      try {
        recipeData = await findRecipe(jsonLd);
        if (recipeData && recipeData.name && recipeData.name.trim() !== "") {
          parsingMethod = "JSON-LD";
          console.log("‚úÖ Successfully parsed with JSON-LD:", recipeData.name);
        } else {
          console.log("‚ö†Ô∏è JSON-LD data incomplete, trying AI...");
          recipeData = null;
        }
      } catch (error) {
        console.log("‚ö†Ô∏è JSON-LD parsing failed:", error.message);
      }
    }

    // Step 3: Fallback to AI parsing if JSON-LD failed
    if (!recipeData) {
      console.log("ü§ñ Using AI parsing...");
      try {
        const cleanHTML = extractRecipeHTML($);
        console.log("üìÑ Extracted HTML length:", cleanHTML.length);

        if (cleanHTML.length < 200) {
          throw new Error("Insufficient content extracted from webpage");
        }

        recipeData = await parseRecipeWithAI(cleanHTML, url);
        parsingMethod = "AI";
        console.log("‚úÖ AI parsing completed:", recipeData.name);
      } catch (error) {
        console.error("‚ùå AI parsing failed:", error.message);
        return res.status(422).json({
          error: "Recipe Extraction Failed",
          message:
            "Could not extract recipe content from this webpage. The page might not contain a recipe, or the content is not accessible.",
          details: error.message,
          suggestion:
            "Try a different recipe URL or manually input the recipe.",
          code: "EXTRACTION_FAILED",
        });
      }
    }

    // Step 4: Validate the parsed data
    const validationErrors = validateRecipeData(recipeData);
    if (validationErrors.length > 0) {
      console.error("‚ùå Validation failed:", validationErrors.join(", "));
      return res.status(422).json({
        error: "Incomplete Recipe Data",
        message: "The parsed recipe data is missing required fields.",
        details: validationErrors.join(", "),
        code: "VALIDATION_ERROR",
      });
    }

    // Step 5: Process and structure the data
    //
    const processedData = sanitizeRecipeData({
      name: recipeData.name?.trim() || "",
      image: recipeData.image || "",
      description: recipeData.description || `A recipe for ${recipeData.name}`,
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: recipeData.category,
      cuisine: recipeData.cuisine,
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url,
      parsingMethod: parsingMethod,
    });
    // Step 6: Enhance the data with another AI call
    console.log("‚ú® Enhancing recipe with AI...");
    const enhancedData = await enhanceRecipeWithAI(processedData);

    // Step 7: Save the final recipe to the database
    console.log("üíæ Saving recipe to the database...");
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing recipe:", error);
    res.status(500).json({
      error: "Server Error",
      message: "An unexpected error occurred while processing the recipe.",
      details: error.message,
    });
  }
});

// Add a new route for manual recipe input
recipeRouter.post("/manual", async (req, res) => {
  try {
    const { recipeText, url } = req.body;

    if (!recipeText) {
      return res.status(400).json({ error: "Recipe text is required" });
    }

    console.log("üìù Processing manually provided recipe text...");

    // Use AI to parse the manually provided text
    const recipeData = await parseRecipeWithAI(
      recipeText,
      url || "manual-input",
    );

    // Process and save as normal
    const processedData = {
      name: recipeData.name.trim(),
      image: recipeData.image || "",
      description: recipeData.description || "Manually added recipe",
      cookTime: recipeData.cookTime || "",
      prepTime: recipeData.prepTime || "",
      totalTime: recipeData.totalTime || "",
      category: Array.isArray(recipeData.category)
        ? recipeData.category
        : [recipeData.category].filter(Boolean),
      cuisine: Array.isArray(recipeData.cuisine)
        ? recipeData.cuisine
        : [recipeData.cuisine].filter(Boolean),
      ingredients: recipeData.ingredients || [],
      instructions: recipeData.instructions || [],
      yield: recipeData.yield || "",
      sourceUrl: url || "manual-input",
      parsingMethod: "Manual + AI",
    };

    // Enhance and save
    const enhancedData = await enhanceRecipeWithAI(processedData);
    const recipe = new Recipe(enhancedData);
    const savedRecipe = await recipe.save();

    console.log("‚úÖ Manual recipe saved successfully:", savedRecipe.name);

    res.status(201).json(savedRecipe);
  } catch (error) {
    console.error("‚ùå Error processing manual recipe:", error);
    res.status(500).json({
      error: "Failed to process manual recipe: " + error.message,
    });
  }
});

recipeRouter.put("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const updatedRecipe = await Recipe.findByIdAndUpdate(id, updates, {
      new: true,
    });

    if (!updatedRecipe) {
      return res.status(404).json({ error: "Recipe not found" });
    }

    res.json(updatedRecipe);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

recipeRouter.get("/:id", async (req, res) => {
  const id = req.params.id;
  const recipe = await Recipe.findById(id);
  res.json(recipe);
});

export { recipeRouter };
```

### üìÑ `index.js`

**Path:** `index.js`  
**Size:** 131 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import {app} from './app.js'
import { PORT } from './utils/config.js'
app.listen(PORT,()=>console.log(`connected on the ${PORT}`))
```

### üìÑ `notes.js`

**Path:** `models/notes.js`  
**Size:** 490 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import mongoose from "mongoose";

const noteSchema = new mongoose.Schema({
  recipeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Recipe",
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    enum: ["chat", "note"],
    required: true,
  },
  isFromAI: {
    type: Boolean,
    default: false,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

export const Note = mongoose.model("Note", noteSchema);
```

### üìÑ `recipe.js`

**Path:** `models/recipe.js`  
**Size:** 813 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import mongoose from "mongoose";

const recipeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  image: {
    type: String  // Changed to handle URL string or object.url
  },
  description: {
    type: String
  },
  cookTime: {
    type: String
  },
  prepTime: {
    type: String
  },
  totalTime: {
    type: String
  },
  category: {
    type: [String]  // Changed to array of strings
  },
  cuisine: {
    type: [String]  // Changed to array of strings
  },
  ingredients: {
    type: [String],
    required: true
  },
  instructions: {
    type: [String],
    required: true
  },
  yield: {
    type: String
  },
  sourceUrl: {
    type: String
  },
  dateAdded: {
    type: Date,
    default: Date.now
  }
});

export const Recipe = mongoose.model("Recipe", recipeSchema);
```

### üìÑ `package.json`

**Path:** `package.json`  
**Size:** 534 B  
**Language:** json (high confidence)  
**Category:** Data/Config  
```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "license": "ISC",
  "author": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node --watch index.js ",
    "start": "node index.js"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "mongodb": "^6.19.0",
    "mongoose": "^8.18.0",
    "tinyduration": "^3.4.1"
  }
}
```

### üìÑ `ai-recipe-parser.js`

**Path:** `utils/ai-recipe-parser.js`  
**Size:** 6.8 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const parseRecipeWithAI = async (htmlContent, url) => {
  console.log("ü§ñ Parsing recipe with AI from HTML content...");
  console.log("üìè Content length:", htmlContent.length);

  if (htmlContent.length < 100) {
    throw new Error("Insufficient content to parse recipe");
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048,
      },
    });

    const contentForAI =
      htmlContent.length > 12000
        ? htmlContent.substring(0, 12000) + "...[content continues]"
        : htmlContent;

    const prompt = `
Analyze this webpage content and extract recipe information. URL: ${url}

Content:
${contentForAI}

Extract recipe details and return a JSON object with this structure:
{
  "name": "Recipe Title",
  "description": "Brief description",
  "image": "image URL as string or empty string",
  "cookTime": "cooking time",
  "prepTime": "prep time", 
  "totalTime": "total time",
  "category": ["category1", "category2"],
  "cuisine": ["cuisine1"],
  "ingredients": ["ingredient 1 with quantity", "ingredient 2"],
  "instructions": ["step 1", "step 2", "step 3"],
  "yield": "servings"
}

IMPORTANT:
- For image field, return ONLY the URL string, not an object
- Extract the actual recipe name from the content
- Find ALL ingredients listed (even if formatting is unclear)
- Extract ALL cooking steps/instructions
- Return valid JSON only, no markdown formatting

JSON:`;

    console.log("üì§ Sending to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    console.log("üì• Raw response length:", text.length);
    console.log("üì• Response preview:", text.substring(0, 150) + "...");

    text = text
      .replace(/```json\s*/g, "")
      .replace(/```\s*/g, "")
      .replace(/`/g, "")
      .trim();

    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      text = jsonMatch[0];
    }

    let aiRecipe;
    try {
      aiRecipe = JSON.parse(text);
    } catch (parseError) {
      console.error("‚ùå JSON parse error:", parseError);
      console.log("üîç Cleaned text:", text);
      throw new Error("AI returned invalid JSON format");
    }

    // Helper function to extract image URL
    const extractImageUrl = (imageData) => {
      if (!imageData) return "";
      if (typeof imageData === "string") return imageData;
      if (Array.isArray(imageData)) {
        const firstImage = imageData[0];
        if (typeof firstImage === "string") return firstImage;
        if (firstImage && firstImage.url) return firstImage.url;
        return "";
      }
      if (imageData.url) return imageData.url;
      return "";
    };

    // Validate and enhance the recipe data
    const validatedRecipe = {
      name: aiRecipe.name?.trim() || `Recipe from ${new URL(url).hostname}`,
      description: aiRecipe.description?.trim() || "A delicious recipe",
      image: extractImageUrl(aiRecipe.image), // Fix: Properly extract image URL
      cookTime: aiRecipe.cookTime || "",
      prepTime: aiRecipe.prepTime || "",
      totalTime: aiRecipe.totalTime || "",
      category: Array.isArray(aiRecipe.category)
        ? aiRecipe.category
        : aiRecipe.category
          ? [aiRecipe.category]
          : ["Main Course"],
      cuisine: Array.isArray(aiRecipe.cuisine)
        ? aiRecipe.cuisine
        : aiRecipe.cuisine
          ? [aiRecipe.cuisine]
          : ["Indian"],
      ingredients:
        Array.isArray(aiRecipe.ingredients) && aiRecipe.ingredients.length > 0
          ? aiRecipe.ingredients
          : [
              "Ingredients not clearly specified - please check the original recipe",
            ],
      instructions:
        Array.isArray(aiRecipe.instructions) && aiRecipe.instructions.length > 0
          ? aiRecipe.instructions
          : [
              "Instructions not clearly specified - please check the original recipe",
            ],
      yield: aiRecipe.yield || "4 servings",
    };

    console.log("‚úÖ Validated recipe:", {
      name: validatedRecipe.name,
      image: validatedRecipe.image,
      ingredientsCount: validatedRecipe.ingredients.length,
      instructionsCount: validatedRecipe.instructions.length,
    });

    return validatedRecipe;
  } catch (error) {
    console.error("‚ùå Error in AI parsing:", error);

    const hostname = new URL(url).hostname;
    return {
      name: `Recipe from ${hostname}`,
      description: `Recipe from ${url} - content could not be fully extracted`,
      image: "", // Fix: Always return string
      cookTime: "",
      prepTime: "",
      totalTime: "",
      category: ["Main Course"],
      cuisine: hostname.includes("indian") ? ["Indian"] : ["Unknown"],
      ingredients: [
        "Ingredients not available - please visit the original recipe",
        `Original URL: ${url}`,
      ],
      instructions: [
        "Instructions not available - please visit the original recipe",
        `Please visit: ${url}`,
      ],
      yield: "4 servings",
    };
  }
};
const enhanceRecipeWithAI = async (recipeData) => {
  console.log("üéØ Enhancing recipe:", recipeData.name);

  // Skip enhancement if the basic data is missing or is a fallback
  if (
    !recipeData.name ||
    recipeData.name.trim() === "" ||
    recipeData.ingredients[0]?.includes("not available") ||
    recipeData.instructions[0]?.includes("not available")
  ) {
    console.log("‚ö†Ô∏è Skipping enhancement - insufficient data");
    return recipeData;
  }

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.1,
      },
    });

    const prompt = `
Improve categorization for this recipe:

Name: ${recipeData.name}
Current categories: ${JSON.stringify(recipeData.category)}
Current cuisines: ${JSON.stringify(recipeData.cuisine)}
First 3 ingredients: ${recipeData.ingredients?.slice(0, 3).join(", ")}

Return only JSON:
{
  "category": ["improved categories"],
  "cuisine": ["improved cuisines"]
}

Categories: Appetizer, Main Course, Dessert, Breakfast, Snack, Side Dish, Soup, Salad
Cuisines: Indian, Italian, Mexican, Asian, American, Mediterranean, Chinese, etc.`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text().trim();

    text = text
      .replace(/```json/g, "")
      .replace(/```/g, "")
      .trim();

    const enhanced = JSON.parse(text);

    return {
      ...recipeData,
      category: enhanced.category || recipeData.category,
      cuisine: enhanced.cuisine || recipeData.cuisine,
    };
  } catch (error) {
    console.error("‚ùå Enhancement failed:", error);
    return recipeData;
  }
};

export { parseRecipeWithAI, enhanceRecipeWithAI };
```

### üìÑ `auth.js`

**Path:** `utils/auth.js`  
**Size:** 1.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import jwt from "jsonwebtoken";
import { User } from "../models/user.js";

// JWT secret from environment variables
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

// Generate JWT token
export const generateToken = (user) => {
  return jwt.sign(
    {
      id: user._id,
      googleId: user.googleId,
      email: user.email,
    },
    JWT_SECRET,
    { expiresIn: "7d" },
  );
};

// Verify JWT token middleware
export const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers["authorization"];
    const token = authHeader && authHeader.split(" ")[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json({ error: "Access token required" });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const user = await User.findById(decoded.id);

    if (!user) {
      return res.status(401).json({ error: "User not found" });
    }

    req.user = user;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    return res.status(403).json({ error: "Invalid token" });
  }
};

// Optional auth middleware (allows both authenticated and anonymous users)
export const optionalAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers["authorization"];
    const token = authHeader && authHeader.split(" ")[1];

    if (token) {
      const decoded = jwt.verify(token, JWT_SECRET);
      const user = await User.findById(decoded.id);
      req.user = user;
    }

    next();
  } catch (error) {
    // Continue without authentication
    next();
  }
};
```

### üìÑ `config.js`

**Path:** `utils/config.js`  
**Size:** 299 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import dotenv from "dotenv";

dotenv.config(); // must be at the top-level before accessing process.env

const PORT = process.env.PORT || 3001;
const url = process.env.MONGODB_URI;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY; // Fixed naming consistency

export { url, PORT, GEMINI_API_KEY };
```

### üìÑ `fetch.js`

**Path:** `utils/fetch.js`  
**Size:** 8.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import * as cheerio from "cheerio";
import * as duration from "tinyduration";

const parseInstructions = (instructions) => {
  let result = [];
  for (let instruction of instructions) {
    if (typeof instruction === "string") result.push(instruction);
    else {
      if (instruction["@type"] === "HowToStep") result.push(instruction.text);
    }
  }
  return result;
};

const findLDJSON = async (u) => {
  console.log("üåê Fetching URL with proper headers:", u);

  try {
    // Add headers to mimic a real browser
    const headers = {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      Accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
      "Accept-Language": "en-US,en;q=0.5",
      "Accept-Encoding": "gzip, deflate, br",
      Connection: "keep-alive",
      "Upgrade-Insecure-Requests": "1",
      "Sec-Fetch-Dest": "document",
      "Sec-Fetch-Mode": "navigate",
      "Sec-Fetch-Site": "none",
      "Cache-Control": "max-age=0",
    };

    let req = await fetch(u, {
      headers,
      method: "GET",
    });

    if (!req.ok) {
      throw new Error(`HTTP ${req.status}: ${req.statusText}`);
    }

    let html = await req.text();

    // Check if we got blocked by firewall
    if (
      html.includes("Sucuri Website Firewall") ||
      html.includes("Access Denied") ||
      html.includes("blocked") ||
      html.length < 1000
    ) {
      console.log("üö´ Request blocked by firewall or bot detection");
      return {
        html: null,
        $: null,
        blocked: true,
        error:
          "Website blocked the request. This site uses anti-bot protection.",
      };
    }

    let $ = cheerio.load(html);
    let jdjson = $("script[type='application/ld+json']");

    if (jdjson.length === 0) {
      console.log("üìÑ No JSON-LD found, will use HTML parsing");
      return { html, $ };
    }

    let content = JSON.parse(jdjson[0].children[0].data);

    if (Array.isArray(content)) return { jsonLd: content[0], html, $ };
    else {
      if (content["@graph"] && Array.isArray(content["@graph"])) {
        for (let t of content["@graph"]) {
          if (t["@type"] === "Recipe") return { jsonLd: t, html, $ };
        }
      }
    }
    return { html, $ };
  } catch (error) {
    console.error("‚ùå Fetch error:", error.message);
    return {
      html: null,
      $: null,
      blocked: true,
      error: `Failed to fetch: ${error.message}`,
    };
  }
};

const durationToStr = (d) => {
  if (!d) return "";
  let parsed = duration.parse(d);
  let result = [];
  if (parsed.hours) {
    result.push(`${parsed.hours} hours`);
  }
  if (parsed.minutes) {
    result.push(`${parsed.minutes} minutes`);
  }
  if (parsed.seconds) {
    result.push(`${parsed.seconds} seconds`);
  }

  let formatter = new Intl.ListFormat("en", {
    style: "long",
    type: "conjunction",
  });
  return formatter.format(result);
};

const findRecipe = async (jdjson) => {
  if (jdjson["@type"].indexOf("Recipe") === -1) return;

  let result = {};
  result.name = jdjson["name"];

  // Fix: Handle ImageObject properly
  if (jdjson["image"]) {
    if (typeof jdjson["image"] === "string") {
      result.image = jdjson["image"];
    } else if (Array.isArray(jdjson["image"])) {
      // Handle array of images - take the first one
      const firstImage = jdjson["image"][0];
      if (typeof firstImage === "string") {
        result.image = firstImage;
      } else if (firstImage && firstImage.url) {
        result.image = firstImage.url;
      } else {
        result.image = "";
      }
    } else if (jdjson["image"].url) {
      // Handle ImageObject
      result.image = jdjson["image"].url;
    } else {
      result.image = "";
    }
  } else {
    result.image = "";
  }

  result.description = jdjson["description"];
  result.cookTime = durationToStr(jdjson["cookTime"]);
  result.prepTime = durationToStr(jdjson["prepTime"]);
  result.totalTime = durationToStr(jdjson["totalTime"]);
  result.category = jdjson["recipeCategory"] ?? "";
  result.cuisine = jdjson["recipeCuisine"] ?? "";
  result.ingredients = jdjson["recipeIngredient"];
  result.instructions = parseInstructions(jdjson["recipeInstructions"]);

  // Fix: Handle recipeYield properly
  if (jdjson["recipeYield"]) {
    if (Array.isArray(jdjson["recipeYield"])) {
      result.yield = jdjson["recipeYield"][0];
    } else {
      result.yield = jdjson["recipeYield"];
    }
  } else {
    result.yield = "";
  }

  return result;
};

const extractRecipeHTML = ($) => {
  if (!$) {
    return "No content available";
  }

  console.log("üîç Extracting recipe content from HTML...");

  // Remove unwanted elements first
  $(
    "script, style, nav, header, footer, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation",
  ).remove();

  let recipeContent = "";
  let contentFound = false;

  // Try multiple strategies to find recipe content
  const strategies = [
    // Strategy 1: Look for recipe-specific selectors
    () => {
      const selectors = [
        '[itemtype*="Recipe"]',
        ".recipe-card",
        ".recipe-content",
        ".recipe-post",
        ".recipe-container",
        ".recipe",
        ".entry-recipe",
        ".post-recipe",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìã Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 2: Look for main content areas
    () => {
      const selectors = [
        "main",
        "article",
        ".entry-content",
        ".post-content",
        ".content",
        "#content",
        ".main-content",
      ];

      for (const selector of selectors) {
        const element = $(selector);
        if (element.length > 0) {
          console.log(`üìÑ Found content with selector: ${selector}`);
          return element.html();
        }
      }
      return null;
    },

    // Strategy 3: Look for specific content patterns
    () => {
      // Look for elements containing recipe keywords
      const recipeKeywords = [
        "ingredients",
        "instructions",
        "directions",
        "recipe",
        "cook",
        "prep",
      ];
      let bestElement = null;
      let maxScore = 0;

      $("div, section, article").each((i, elem) => {
        const $elem = $(elem);
        const text = $elem.text().toLowerCase();
        let score = 0;

        recipeKeywords.forEach((keyword) => {
          if (text.includes(keyword)) score++;
        });

        if (score > maxScore && $elem.text().length > 200) {
          maxScore = score;
          bestElement = $elem;
        }
      });

      if (bestElement) {
        console.log(
          `üéØ Found content with keyword matching (score: ${maxScore})`,
        );
        return bestElement.html();
      }
      return null;
    },

    // Strategy 4: Fallback to body content
    () => {
      console.log("üì¶ Using full body content as fallback");
      return $("body").html();
    },
  ];

  // Try each strategy until we find content
  for (const strategy of strategies) {
    const content = strategy();
    if (content && content.length > 100) {
      // Minimum content length
      recipeContent = content;
      contentFound = true;
      break;
    }
  }

  if (!contentFound) {
    console.log("‚ùå No substantial content found");
    return "No recipe content found";
  }

  // Clean up the extracted content
  const cleanedContent = cheerio.load(recipeContent);

  // Remove more unwanted elements from the extracted content
  cleanedContent(
    "script, style, .advertisement, .ads, .social-share, .comments, .sidebar, .menu, .navigation, .popup, .modal",
  ).remove();

  // Get text content and clean it up
  let textContent = cleanedContent.text();

  // Clean up whitespace and formatting
  textContent = textContent
    .replace(/\s+/g, " ") // Replace multiple whitespace with single space
    .replace(/\n\s*\n/g, "\n") // Remove empty lines
    .trim();

  console.log(`üìè Extracted content length: ${textContent.length} characters`);

  return textContent;
};

export { findLDJSON, findRecipe, extractRecipeHTML };
```

### üìÑ `gemini.js`

**Path:** `utils/gemini.js`  
**Size:** 3.2 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const enhanceRecipeWithAI = async (recipeData) => {
  console.log("ü§ñ Starting AI enhancement for recipe:", recipeData.name);
  console.log("üìä Original data:", {
    category: recipeData.category,
    cuisine: recipeData.cuisine,
    ingredients: recipeData.ingredients?.slice(0, 3) // Just first 3 for logging
  });

  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    const prompt = `
Please analyze this recipe data and provide better categorization and cataloguing. 
Return ONLY a valid JSON object (no markdown, no code blocks, no additional text).

Expected format:
{
  "category": ["array", "of", "categories"],
  "cuisine": ["array", "of", "cuisines"],
  "name": "improved recipe name if needed",
  "description": "improved description if needed"
}

Recipe data to analyze:
Name: ${recipeData.name}
Description: ${recipeData.description}
Ingredients: ${recipeData.ingredients?.join(', ')}
Instructions: ${recipeData.instructions?.slice(0, 3).join('. ')}
Original Category: ${recipeData.category}
Original Cuisine: ${recipeData.cuisine}

Focus on:
- Better food categories (e.g., "Dessert", "Main Course", "Appetizer", "Breakfast", "Snack")
- More specific cuisine types (e.g., "Italian", "Mexican", "Asian", "Mediterranean")
- Keep the same name and description unless they need minor improvements

IMPORTANT: Return ONLY the JSON object, no other text or formatting.
`;

    console.log("üì§ Sending prompt to AI...");
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();
    
    console.log("üì• Raw AI response:", text);
    
    // Clean the response to extract JSON
    text = text.trim();
    
    // Remove markdown code blocks if present
    if (text.startsWith('```json')) {
      text = text.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    } else if (text.startsWith('```')) {
      text = text.replace(/^```\s*/, '').replace(/\s*```$/, '');
    }
    
    // Remove any remaining backticks
    text = text.replace(/`/g, '');
    
    console.log("üßπ Cleaned response:", text);
    
    // Parse the AI response
    const aiEnhancements = JSON.parse(text.trim());
    console.log("‚úÖ Parsed AI enhancements:", aiEnhancements);
    
    const enhancedData = {
      ...recipeData,
      category: aiEnhancements.category || recipeData.category,
      cuisine: aiEnhancements.cuisine || recipeData.cuisine,
      name: aiEnhancements.name || recipeData.name,
      description: aiEnhancements.description || recipeData.description
    };

    console.log("üéØ Final enhanced data:", {
      category: enhancedData.category,
      cuisine: enhancedData.cuisine,
      nameChanged: enhancedData.name !== recipeData.name,
      descriptionChanged: enhancedData.description !== recipeData.description
    });
    
    return enhancedData;
    
  } catch (error) {
    console.error("‚ùå Error enhancing recipe with AI:", error);
    console.log("üîÑ Falling back to original data");
    // Return original data if AI processing fails
    return recipeData;
  }
};

export { enhanceRecipeWithAI };
```

### üìÑ `recipe-chat-ai.js`

**Path:** `utils/recipe-chat-ai.js`  
**Size:** 3 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { GoogleGenerativeAI } from "@google/generative-ai";
import "dotenv/config";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const chatWithRecipeAI = async (recipe, userMessage) => {
  console.log("ü§ñ Processing chat about recipe:", recipe.name);

  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 2048, // Increased from 1024
        responseMimeType: "text/plain", // Changed from JSON
      },
    });

    const recipeContext = `
Recipe: ${recipe.name}
Description: ${recipe.description}
Prep Time: ${recipe.prepTime}
Cook Time: ${recipe.cookTime}
Total Time: ${recipe.totalTime}
Serves: ${recipe.yield}
Category: ${recipe.category?.join(", ")}
Cuisine: ${recipe.cuisine?.join(", ")}

Ingredients:
${recipe.ingredients?.map((ing, i) => `${i + 1}. ${ing}`).join("\n")}

Instructions:
${recipe.instructions?.map((inst, i) => `${i + 1}. ${inst}`).join("\n")}
`;

    const prompt = `
You are a helpful cooking assistant chatting with someone about a recipe. Keep your response conversational, friendly, and well-formatted.

Recipe Context:
${recipeContext}

User Question: "${userMessage}"

Guidelines for your response:
- Write in a friendly, conversational tone
- Use proper paragraphs and line breaks for readability
- If suggesting substitutions, format them clearly with bullet points
- Keep cooking tips organized and easy to read
- End with an encouraging note or follow-up question if appropriate
- Maximum 3-4 paragraphs unless they ask for detailed instructions
- Use emojis sparingly and appropriately

Provide a helpful response:`;

    const result = await model.generateContent(prompt);
    const response = await result.response;

    const cleanResponse = response.text().trim();

    // Add some basic formatting if the response is too long or poorly structured
    const formattedResponse = formatChatResponse(cleanResponse);

    console.log("‚úÖ Generated response length:", formattedResponse.length);

    return formattedResponse;
  } catch (error) {
    console.error("‚ùå Error in recipe chat AI:", error);
    return "I'm sorry, I couldn't process your question right now. Please try again later.";
  }
};

// Helper function to format the AI response
const formatChatResponse = (response) => {
  // Remove any JSON artifacts that might have leaked through
  let formatted = response.replace(/^```json\s*/, "").replace(/```$/, "");
  formatted = formatted
    .replace(/^\{[\s\S]*?"response":\s*"/, "")
    .replace(/"[\s\S]*\}$/, "");

  // Clean up common formatting issues
  formatted = formatted
    .replace(/\*\*/g, "") // Remove markdown bold
    .replace(/\* /g, "\n‚Ä¢ ") // Convert asterisk lists to bullet points
    .replace(/\n\n\n+/g, "\n\n") // Remove excessive line breaks
    .replace(/^\n+/, "") // Remove leading newlines
    .replace(/\n+$/, ""); // Remove trailing newlines

  // Ensure proper paragraph breaks
  formatted = formatted.replace(/([.!?])\s*([A-Z])/g, "$1\n\n$2");

  return formatted;
};

export { chatWithRecipeAI };
```

---

### üìä Processing Summary

- **Files Processed:** 13
- **Files Skipped:** 0
- **Total Files:** 13
- **Concurrency Limit:** 2
